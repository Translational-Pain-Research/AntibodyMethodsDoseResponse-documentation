<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Fitting · AntibodyMethodsDoseResponse</title><meta name="title" content="Fitting · AntibodyMethodsDoseResponse"/><meta property="og:title" content="Fitting · AntibodyMethodsDoseResponse"/><meta property="twitter:title" content="Fitting · AntibodyMethodsDoseResponse"/><meta name="description" content="Documentation for AntibodyMethodsDoseResponse."/><meta property="og:description" content="Documentation for AntibodyMethodsDoseResponse."/><meta property="twitter:description" content="Documentation for AntibodyMethodsDoseResponse."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="AntibodyMethodsDoseResponse logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">AntibodyMethodsDoseResponse</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../QuickStart/">Quick start</a></li><li><span class="tocitem">Detailed explanations</span><ul><li><a class="tocitem" href="../MeasurementData/">Measurement data</a></li><li><a class="tocitem" href="../Models/">Models</a></li><li><a class="tocitem" href="../ResultsAndSimulations/">Results and simulations</a></li><li><a class="tocitem" href="../DensityPlots/">Density plots for <code>OneDimGrid</code></a></li><li class="is-active"><a class="tocitem" href>Fitting</a><ul class="internal"><li><a class="tocitem" href="#The-setting"><span>The setting</span></a></li><li><a class="tocitem" href="#Simple-model-fitting"><span>Simple model fitting</span></a></li><li><a class="tocitem" href="#adaptive_model_fitting"><span>Adaptive model fitting</span></a></li><li><a class="tocitem" href="#The-same-options-in-the-convenience-workflow"><span>The same options in the convenience workflow</span></a></li><li><a class="tocitem" href="#Multi-threaded-fitting"><span>Multi-threaded fitting</span></a></li><li><a class="tocitem" href="#Changing-the-initial-values"><span>Changing the initial values</span></a></li></ul></li><li><a class="tocitem" href="../Uncertainty/">Uncertainty estimation</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../API/">AntibodyMethodsDoseResponse</a></li><li><a class="tocitem" href="../API_Convenience/">AntibodyMethodsDoseResponseConvenience</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Detailed explanations</a></li><li class="is-active"><a href>Fitting</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Fitting</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Translational-Pain-Research/AntibodyMethodsDoseResponse.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Translational-Pain-Research/AntibodyMethodsDoseResponse.jl/blob/main/docs/src/Fitting.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="fitting"><a class="docs-heading-anchor" href="#fitting">Fitting</a><a id="fitting-1"></a><a class="docs-heading-anchor-permalink" href="#fitting" title="Permalink"></a></h1><p>The model generators return a <a href="https://translational-pain-research.github.io/FittingObjectiveFunctions-documentation/API/#FittingObjectiveFunctions.ModelFunctions"><code>ModelFunctions</code></a> object. The <code>model</code> field of a <a href="https://translational-pain-research.github.io/FittingObjectiveFunctions-documentation/API/#FittingObjectiveFunctions.ModelFunctions"><code>ModelFunctions</code></a> object is a pure Julia function, allowing to implement the model fitting from scratch.</p><pre><code class="language-julia hljs">using AntibodyMethodsDoseResponseConvenience
model, params = accumulation_model(create_grid([1,2,3]))
typeof(model.model) &lt;: Function</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Yet, since the model generators create a <a href="https://translational-pain-research.github.io/FittingObjectiveFunctions-documentation/API/#FittingObjectiveFunctions.ModelFunctions"><code>ModelFunctions</code></a> object, it is convenient to construct the fitting objective with <a href="https://translational-pain-research.github.io/FittingObjectiveFunctions-documentation/"><code>FittingObjectiveFunctions.jl</code></a>. Then, only the minimization/maximization of the objective function remains to be implemented. Because these steps are always the same, the <a href="../API/#AntibodyMethodsDoseResponse.adaptive_dose_response_fit"><code>adaptive_dose_response_fit</code></a> function summarizes the creation of the model function and the objective function, requiring only the implementation of a function minimizer.</p><div class="admonition is-success"><header class="admonition-header">Reminder: Convenience workflow</header><div class="admonition-body"><p>If there is no reason to avoid the dependencies of <a href="https://github.com/Translational-Pain-Research/AntibodyMethodsDoseResponseConvenience.jl"><code>AntibodyMethodsDoseResponseConvenience.jl</code></a>, the workflow as described in the <a href="../QuickStart/#quick_start">quick start guide</a> should be used. <a href="../API_Convenience/#AntibodyMethodsDoseResponseConvenience.FittingCondition"><code>FittingCondition</code></a> and <a href="../API_Convenience/#AntibodyMethodsDoseResponseConvenience.fit_condition"><code>fit_condition</code></a> expose the same options that are described here.</p></div></div><h2 id="The-setting"><a class="docs-heading-anchor" href="#The-setting">The setting</a><a id="The-setting-1"></a><a class="docs-heading-anchor-permalink" href="#The-setting" title="Permalink"></a></h2><p>We consider the following measurement data <code>(concentrations, responses, errors)</code>:</p><pre><code class="language-julia hljs">scatter(concentrations,responses, yerror = errors, xaxis = :log, legend = :none)</code></pre><img src="b6202052.svg" alt="Example block output"/><h2 id="Simple-model-fitting"><a class="docs-heading-anchor" href="#Simple-model-fitting">Simple model fitting</a><a id="Simple-model-fitting-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-model-fitting" title="Permalink"></a></h2><p>The data needs to be summarized in a <a href="https://translational-pain-research.github.io/FittingObjectiveFunctions-documentation/API/#FittingObjectiveFunctions.FittingData"><code>FittingData</code></a> object, as described in <a href="../Models/#binding_models">Models</a>:</p><pre><code class="language-julia hljs">data = FittingData(concentrations, responses, errors)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">FittingData([1.0e-10, 3.414548873833601e-10, 1.1659144011798312e-9, 3.981071705534969e-9, 1.3593563908785241e-8, 4.641588833612773e-8, 1.584893192461114e-7, 5.411695265464649e-7, 1.8478497974222906e-6, 6.309573444801943e-6, 2.1544346900318823e-5, 7.356422544596421e-5, 0.0002511886431509585, 0.0008576958985908955, 0.0029286445646252404, 0.01000000000000001], [0.00021410640885032888, 0.0007663741382536124, 0.0022904228427114396, 0.007480511858978876, 0.02234921802107462, 0.06800642522811402, 0.1999605075743781, 0.48627646991166545, 0.8640377791882656, 1.1066809652565421, 1.2718676867480627, 1.5954463405164325, 2.0827667975228743, 2.038420572824142, 2.129076978959971, 2.12713266152728], [9.038975931520719e-6, 7.48542293064205e-5, 0.0001715062199824497, 0.0006347118571287526, 0.0009298400467954249, 0.0034907971363670695, 0.002630265790858374, 0.04611199595837917, 0.014791696364573545, 0.06862939569552252, 0.03683894761707063, 0.09538214293549667, 0.15611494403288997, 0.03885184183872844, 0.146064853827133, 0.04829619497432603], Function[FittingObjectiveFunctions.normal_distribution, FittingObjectiveFunctions.normal_distribution, FittingObjectiveFunctions.normal_distribution, FittingObjectiveFunctions.normal_distribution, FittingObjectiveFunctions.normal_distribution, FittingObjectiveFunctions.normal_distribution, FittingObjectiveFunctions.normal_distribution, FittingObjectiveFunctions.normal_distribution, FittingObjectiveFunctions.normal_distribution, FittingObjectiveFunctions.normal_distribution, FittingObjectiveFunctions.normal_distribution, FittingObjectiveFunctions.normal_distribution, FittingObjectiveFunctions.normal_distribution, FittingObjectiveFunctions.normal_distribution, FittingObjectiveFunctions.normal_distribution, FittingObjectiveFunctions.normal_distribution])</code></pre><p>Next, a <code>OneDimGrid</code> needs to be created, ideally covering the concentration range:</p><pre><code class="language-julia hljs">grid = create_grid(LogRange(1e-10,1e-2,40))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AdaptiveDensityApproximation.OneDimGrid{Dict{String, AdaptiveDensityApproximation.OneDimBlock}}(Dict{String, AdaptiveDensityApproximation.OneDimBlock}(&quot;ObmYcgCruP&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;ObmYcgCruP&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(8.376776400682924e-6, 1.3433993325989015e-5), [&quot;PZ0hNQzpBe&quot;, &quot;bjCfgdnRkW&quot;], 1.0), &quot;m2mnfvIIWx&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;m2mnfvIIWx&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(7.017038286703837e-9, 1.1253355826007646e-8), [&quot;f7BJs6IbHA&quot;, &quot;QCuKIQBoMW&quot;], 1.0), &quot;AXkRtlUZmM&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;AXkRtlUZmM&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(1.6037187437513343e-10, 2.571913809059347e-10), [&quot;1kIAUJawhi&quot;, &quot;XdfXW9WC4a&quot;], 1.0), &quot;xKKjDLU8ns&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;xKKjDLU8ns&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(6.614740641230159e-10, 1.0608183551394483e-9), [&quot;IWO6v2aSD7&quot;, &quot;2o4jn6PXC0&quot;], 1.0), &quot;YAMJwlYch7&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;YAMJwlYch7&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(0.00014251026703029993, 0.00022854638641349884), [&quot;teOB8JlWy3&quot;, &quot;d35bCQMLJw&quot;], 1.0), &quot;aO8JsUZzJx&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;aO8JsUZzJx&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(0.000366524123707963, 0.0005878016072274918), [&quot;d35bCQMLJw&quot;, &quot;zfQs3TQaRn&quot;], 1.0), &quot;DNpbU89Gxw&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;DNpbU89Gxw&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(5.5410203300095034e-5, 8.886238162743407e-5), [&quot;3Xsb2ZTZJf&quot;, &quot;teOB8JlWy3&quot;], 1.0), &quot;5JqHgOLdHN&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;5JqHgOLdHN&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(0.0015117750706156647, 0.0024244620170823334), [&quot;3ojA4bSEiI&quot;, &quot;FtUjCxyezj&quot;], 1.0), &quot;f7BJs6IbHA&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;f7BJs6IbHA&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(4.37547937507418e-9, 7.017038286703837e-9), [&quot;M98LuOw7H3&quot;, &quot;m2mnfvIIWx&quot;], 1.0), &quot;MnBvkqlPmu&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;MnBvkqlPmu&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(1.7012542798525856e-9, 2.7283333764867695e-9), [&quot;2o4jn6PXC0&quot;, &quot;M98LuOw7H3&quot;], 1.0)…))</code></pre><p>Finally, a function minimizer needs to be implemented. For this, we use <a href="https://julianlsolvers.github.io/Optim.jl/stable/"><code>Optim.jl</code></a>, here:</p><pre><code class="language-julia hljs">function minimizer(f,∇f,init)
	lower = zeros(length(init))
	upper = [Inf for i in 1:length(init)]
	return optimize(f,lower,upper, init, Fminbox(NelderMead()),
			Optim.Options(g_tol = 1e-12, iterations =2000)).minimizer
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">minimizer (generic function with 1 method)</code></pre><p>The implemented <code>minimizer</code> must take the objective function <code>f</code>, its gradient function <code>∇f</code>, if applicable, and an initial parameter array <code>init</code> as arguments and return the minimizing parameters. Furthermore, since <span>$K_\tau \geq 0$</span>, the optimization domain should be limited.</p><p>Now, a model can be fitted to the <code>data</code> with <a href="../API/#AntibodyMethodsDoseResponse.adaptive_dose_response_fit"><code>adaptive_dose_response_fit</code></a>:</p><pre><code class="language-julia hljs">result = adaptive_dose_response_fit(grid,data,
		minimizer, 
		options = AdaptiveOptions(model = accumulation_model)
	)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AdaptiveResult(DoseResponseResult([1.0e-10, 3.414548873833601e-10, 1.1659144011798312e-9, 3.981071705534969e-9, 1.3593563908785241e-8, 4.641588833612773e-8, 1.584893192461114e-7, 5.411695265464649e-7, 1.8478497974222906e-6, 6.309573444801943e-6, 2.1544346900318823e-5, 7.356422544596421e-5, 0.0002511886431509585, 0.0008576958985908955, 0.0029286445646252404, 0.01000000000000001], [0.00021579057077205242, 0.0007200106941876133, 0.00233851080138543, 0.007310962721306748, 0.022365018634090086, 0.06855254335691059, 0.19988219755490758, 0.4865341557734796, 0.8619866014673013, 1.116069451416069, 1.282043175222575, 1.5899059699965077, 1.9337471786888933, 2.0466840753162447, 2.085767901947363, 2.128150357841314]), AdaptiveDensityApproximation.OneDimGrid{Dict{String, AdaptiveDensityApproximation.OneDimBlock}}(Dict{String, AdaptiveDensityApproximation.OneDimBlock}(&quot;CFFr16mqVP&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;CFFr16mqVP&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(1.0e-10, 1.6037187437513343e-10), [&quot;Z3KyK0Lpiy&quot;], 4.832107825716488e-7), &quot;42mX0upIT8&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;42mX0upIT8&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(4.37547937507418e-9, 7.017038286703837e-9), [&quot;sMJgBlnMHk&quot;, &quot;0GmhhkTb5Q&quot;], 0.00021532439734844885), &quot;iTsAt9PhSw&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;iTsAt9PhSw&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(0.000366524123707963, 0.0005878016072274918), [&quot;dvi92bYdAr&quot;, &quot;Si8hzfA11e&quot;], 1.0486616630043566e-5), &quot;EPW04uCBRJ&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;EPW04uCBRJ&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(3.4551072945922186e-5, 5.5410203300095034e-5), [&quot;dnCm8OkGAL&quot;, &quot;U5fIpdFyyC&quot;], 0.12881298051746065), &quot;yJWkMirbGX&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;yJWkMirbGX&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(8.376776400682924e-6, 1.3433993325989015e-5), [&quot;WEtKDDvB3M&quot;, &quot;49y8BI1iOi&quot;], 1.872669767651622e-6), &quot;IUOe38I5vI&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;IUOe38I5vI&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(6.614740641230159e-10, 1.0608183551394483e-9), [&quot;CcsayAsd7n&quot;, &quot;8HVVqnKKp7&quot;], 1.153937222274246e-5), &quot;dvi92bYdAr&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;dvi92bYdAr&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(0.00022854638641349884, 0.000366524123707963), [&quot;5VNAmvdDYC&quot;, &quot;iTsAt9PhSw&quot;], 1.554851977125376e-5), &quot;bvOVRPJ4sS&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;bvOVRPJ4sS&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(4.641588833612773e-8, 7.443803013251697e-8), [&quot;NiHrS4W9P1&quot;, &quot;zQaddlToMN&quot;], 1.3017144684781726e-5), &quot;fjXoq3p3tG&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;fjXoq3p3tG&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(1.7012542798525856e-9, 2.7283333764867695e-9), [&quot;8HVVqnKKp7&quot;, &quot;sMJgBlnMHk&quot;], 0.0007129551951835721), &quot;aXK1bXt9fw&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;aXK1bXt9fw&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(1.8047217668271702e-8, 2.8942661247167517e-8), [&quot;62bZEsIJ0G&quot;, &quot;NiHrS4W9P1&quot;], 0.0004056230740643861)…)), [4.832107825716488e-7, 6.415183730561543e-6, 1.954877714344995e-5, 9.309041596690905e-10, 1.153937222274246e-5, 5.6546893420221556e-5, 0.0007129551951835721, 7.949876627202987e-5, 0.00021532439734844885, 0.0006877136582204332  …  0.320097502888623, 0.20583689191073756, 1.554851977125376e-5, 1.0486616630043566e-5, 9.65296207565328e-6, 1.313506765963266e-5, 0.020623421375504308, 0.03389682370230051, 0.03880926072454446, 0.02342825077704379], 1.7563840306558678, 1.8065428733825684)</code></pre><p><code>adaptive_dose_response_fit</code> returns an <a href="../API/#AntibodyMethodsDoseResponse.AdaptiveResult"><code>AdaptiveResult</code></a> object, that has the following fields:</p><ul><li><code>optimizer</code>: The estimated parameters (result of model fitting).</li><li><code>objective_value</code>: The objective function value for the estimated parameters.</li><li><code>grid</code>: A grid containing the estimated parameters as grid weights.</li><li><code>result</code>: The <a href="../API/#AntibodyMethodsDoseResponse.DoseResponseResult"><code>DoseResponseResult</code></a> object corresponding to the grid (and the offset parameter).</li><li><code>time</code>: The elapsed time for the model fit (in seconds).</li></ul><pre><code class="language-julia hljs">scatter(data, xaxis = :log, legend = :topleft, label = &quot;data&quot;)
plot!(result.result, label = &quot;fit result&quot;)</code></pre><img src="eb4ed451.svg" alt="Example block output"/><pre><code class="language-julia hljs">plot(DensityPlot(result.grid), xaxis = :log, color = 2, fill = 0,
	fillalpha = 0.5, label = &quot;fit result&quot;)</code></pre><img src="89d211f3.svg" alt="Example block output"/><h2 id="adaptive_model_fitting"><a class="docs-heading-anchor" href="#adaptive_model_fitting">Adaptive model fitting</a><a id="adaptive_model_fitting-1"></a><a class="docs-heading-anchor-permalink" href="#adaptive_model_fitting" title="Permalink"></a></h2><p>The model fit above can be improved in two areas. First, a regularization could be used. Second, the adaptive density approximation from <a href="https://translational-pain-research.github.io/AdaptiveDensityApproximation-documentation/"><code>AdaptiveDensityApproximation.jl</code></a> could be used to reduce the number of parameters. Here, we recreate the default optimization from the <a href="https://github.com/Translational-Pain-Research/AntibodyMethodsDoseResponseConvenience.jl"><code>AntibodyMethodsDoseResponseConvenience.jl</code></a> package as described in the <a href="../QuickStart/#quick_start">quick start guide</a> to illustrate some of the available options.</p><h3 id="Setting-up-the-objective-function-properties"><a class="docs-heading-anchor" href="#Setting-up-the-objective-function-properties">Setting up the objective function properties</a><a id="Setting-up-the-objective-function-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-up-the-objective-function-properties" title="Permalink"></a></h3><p>For the regularization, a log-posterior objective can be used, where a smoothing prior defines the regularization. </p><p>Log-posterior objectives differ from posterior objectives only by taking the logarithm of all functions. Mathematically, there is no difference, but for the computation of tiny probabilities, taking the logarithm upfront is numerically beneficial. Accordingly, the prior also needs to be defined as log-prior, i.e. as the logarithm of the prior.</p><p>While <a href="https://translational-pain-research.github.io/FittingObjectiveFunctions-documentation/"><code>FittingObjectiveFunctions.jl</code></a> expects standard functions as prior/log-prior, <a href="../API/#AntibodyMethodsDoseResponse.adaptive_dose_response_fit"><code>adaptive_dose_response_fit</code></a> requires a prior-generating function (Here, the <code>500</code> is used to reproduce the <code>scale = 500</code> from the <a href="../QuickStart/#quick_start">quick start guide</a>):</p><pre><code class="language-julia hljs">function log_prior_generator(centers, volumes, offset)
	ℓV = log.(centers .+ volumes/2) .- log.(centers .- volumes/2)
	if isnothing(offset)
		return λ -&gt;  -500*(sum((λ[i]/ℓV[i]-λ[i+1]/ℓV[i+1])^2 for i in 1:length(λ)-1))/length(λ)^2
	else
		return λ -&gt; -500*(sum((λ[i]/ℓV[i]-λ[i+1]/ℓV[i+1])^2 for i in 1:length(λ)-2) + λ[end]^2)/length(λ)^2
	end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">log_prior_generator (generic function with 1 method)</code></pre><p>The prior generator above will create a new log-prior function for each step of the adaptive fitting. The returned log-prior function reads:</p><p class="math-container">\[\text{log-prior}(\lambda) = -\frac{500}{\text{length}(\lambda)^2} \left(\lambda_{\text{offset}} + \sum_{i=1}^{n-1} \left( \frac{\lambda_i}{\ell V_i} - \frac{\lambda_{i+1}}{\ell V_{i+1}} \right)^2 \right)\]</p><p>Since the default density-visualization of grids rescales the weights by using the visual interval lengths in a logarithmic scale <code>ℓV</code> (see <a href="../DensityPlots/#log_volume_normalization">Background: log-volume normalization</a>), the smoothing should be applied to the rescaled parameters <code>λ</code>. Hence, the <code>λ[i]</code> are divided by <code>ℓV[i]</code>.</p><p>Next, observe that the log-prior is just the logarithm of a normal distribution (up to a missing normalization) for the difference of the rescaled parameters. Essentially, the prior assumes that there is no difference between neighboring parameters where the scale <span>$\frac{500}{\text{length}(\lambda)^2}$</span> expresses the strength/importance of this assumption. This is the aforementioned smoothing.</p><div class="admonition is-info"><header class="admonition-header">Why prior-generator functions?</header><div class="admonition-body"><p>Using log-prior generating functions seems unnecessarily complicated, at first. However, during the adaptive fit, the underlying grid approximation changes, leading to different (visual) interval lengths. Defining a fixed function for the prior could not take the change of interval lengths into account, i.e. the parameters could not be rescaled properly. Hence, the prior needs to be recalculated after every change of the grid, which requires a function that generates the prior from the grid properties.</p></div></div><p>Without additional information about the measurement errors, a normal distribution is a sensible choice for the uncertainty distribution. Since the goal is a log-posterior objective, the logarithm of a normal distribution <code>(y,m,Δy)-&gt; -(y-m)^2/Δy^2</code> must be used:</p><pre><code class="language-julia hljs">data = FittingData(concentrations,responses, errors, distributions = (y,m,Δy)-&gt; -(y-m)^2/Δy^2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">FittingData([1.0e-10, 3.414548873833601e-10, 1.1659144011798312e-9, 3.981071705534969e-9, 1.3593563908785241e-8, 4.641588833612773e-8, 1.584893192461114e-7, 5.411695265464649e-7, 1.8478497974222906e-6, 6.309573444801943e-6, 2.1544346900318823e-5, 7.356422544596421e-5, 0.0002511886431509585, 0.0008576958985908955, 0.0029286445646252404, 0.01000000000000001], [0.00021410640885032888, 0.0007663741382536124, 0.0022904228427114396, 0.007480511858978876, 0.02234921802107462, 0.06800642522811402, 0.1999605075743781, 0.48627646991166545, 0.8640377791882656, 1.1066809652565421, 1.2718676867480627, 1.5954463405164325, 2.0827667975228743, 2.038420572824142, 2.129076978959971, 2.12713266152728], [9.038975931520719e-6, 7.48542293064205e-5, 0.0001715062199824497, 0.0006347118571287526, 0.0009298400467954249, 0.0034907971363670695, 0.002630265790858374, 0.04611199595837917, 0.014791696364573545, 0.06862939569552252, 0.03683894761707063, 0.09538214293549667, 0.15611494403288997, 0.03885184183872844, 0.146064853827133, 0.04829619497432603], Function[Main.var&quot;#11#12&quot;(), Main.var&quot;#11#12&quot;(), Main.var&quot;#11#12&quot;(), Main.var&quot;#11#12&quot;(), Main.var&quot;#11#12&quot;(), Main.var&quot;#11#12&quot;(), Main.var&quot;#11#12&quot;(), Main.var&quot;#11#12&quot;(), Main.var&quot;#11#12&quot;(), Main.var&quot;#11#12&quot;(), Main.var&quot;#11#12&quot;(), Main.var&quot;#11#12&quot;(), Main.var&quot;#11#12&quot;(), Main.var&quot;#11#12&quot;(), Main.var&quot;#11#12&quot;(), Main.var&quot;#11#12&quot;()])</code></pre><p>Here, <code>y</code> denotes the data point value, <code>m</code> denotes the model value calculated from the parameters and <code>Δy</code> denotes the measurement error. Uncertainty distributions must take the arguments in this order <code>(y,m,Δy)</code> and must return the distribution / log-distribution value.</p><h3 id="Setting-up-the-minimizers"><a class="docs-heading-anchor" href="#Setting-up-the-minimizers">Setting up the minimizers</a><a id="Setting-up-the-minimizers-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-up-the-minimizers" title="Permalink"></a></h3><p>As before, a minimizer needs to be defined:</p><pre><code class="language-julia hljs">function minimizer(f,∇f,init)
	lower = zeros(length(init))
	upper = [Inf for i in 1:length(init)]
	return optimize(f,lower,upper, init, Fminbox(NelderMead()),
		Optim.Options(g_tol = 1e-12, iterations =2000)).minimizer
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">minimizer (generic function with 1 method)</code></pre><div class="admonition is-info"><header class="admonition-header">Minimization and log-posterior?</header><div class="admonition-body"><p>Likelihood and posterior objectives usually need to be maximized. However, <code>Optim.jl</code> only provides minimizers, as do some other optimization packages, expecting from the user to flip the sign of the function for a maximization. <a href="../API/#AntibodyMethodsDoseResponse.adaptive_dose_response_fit"><code>adaptive_dose_response_fit</code></a> flips the sign of the posterior and log-posterior objectives automatically.</p></div></div><p>But, to recreate the default fitting from the <a href="../QuickStart/#quick_start">quick start guide</a>, a second minimizer is needed (using the <code>LBFGS</code> algorithm):</p><pre><code class="language-julia hljs">function post_minimizer(f,∇f,init)
	lower = zeros(length(init))
	upper = [Inf for i in 1:length(init)]
	return optimize(f,lower,upper, init, Fminbox(LBFGS()),
		Optim.Options(g_tol = 1e-12, iterations =2000)).minimizer
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">post_minimizer (generic function with 1 method)</code></pre><p>The second minimizer will be applied after the adaptive optimization to fine-tune the results with a gradient based minimizer. </p><h3 id="Setting-up-the-options"><a class="docs-heading-anchor" href="#Setting-up-the-options">Setting up the options</a><a id="Setting-up-the-options-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-up-the-options" title="Permalink"></a></h3><p>Before fitting the data, the fitting options (<a href="../API/#AntibodyMethodsDoseResponse.AdaptiveOptions"><code>AdaptiveOptions</code></a>) and the initial grid need to be defined. Among others, the objective and the prior-generator defined above need to be selected (the additional options in the example are needed to obtain the defaults from the <a href="../QuickStart/#quick_start">quick start guide</a>):</p><pre><code class="language-julia hljs">adaptive_options = AdaptiveOptions(objective = :log_posterior,
	iterations = 30,
	offset = eps(),
	prior_generator = log_prior_generator
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AdaptiveOptions(&quot;Adaptive optimization&quot;, true, 30, AntibodyMethodsDoseResponse.accumulation_model, 2.220446049250313e-16, :log_posterior, Main.log_prior_generator, nothing, AntibodyMethodsDoseResponse.default_prior_gradient_generator, AntibodyMethodsDoseResponse.log_area_scaled_variation, maximum)</code></pre><p>The idea of the adaptive approximation is to start with a coarse grid, containing only 2 intervals (3 interval edges):</p><pre><code class="language-julia hljs">grid = create_grid(LogRange(1e-10,1e-2,3))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AdaptiveDensityApproximation.OneDimGrid{Dict{String, AdaptiveDensityApproximation.OneDimBlock}}(Dict{String, AdaptiveDensityApproximation.OneDimBlock}(&quot;rORXhvax2O&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;rORXhvax2O&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(1.0e-10, 1.0e-6), [&quot;mMf26k9w6y&quot;], 1.0), &quot;mMf26k9w6y&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;mMf26k9w6y&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(1.0e-6, 0.01000000000000001), [&quot;rORXhvax2O&quot;], 1.0)))</code></pre><div class="admonition is-info"><header class="admonition-header">Adaptive fitting</header><div class="admonition-body"><p>With only 2 parameters, common optimizers find a good minimum even for suboptimal initial parameters. Then, the grid can be refined in regions of interest. Next, the previous result can be used as good initial point for the optimization. This process can be repeated several times, increasing the number intervals for regions of interest while not wasting computation time with small intervals for uninteresting regions.</p></div></div><h3 id="Fitting"><a class="docs-heading-anchor" href="#Fitting">Fitting</a><a id="Fitting-1"></a><a class="docs-heading-anchor-permalink" href="#Fitting" title="Permalink"></a></h3><p>Now, the data can be fitted with <a href="../API/#AntibodyMethodsDoseResponse.adaptive_dose_response_fit"><code>adaptive_dose_response_fit</code></a>:</p><pre><code class="language-julia hljs">adaptive_result = adaptive_dose_response_fit(grid,data,minimizer, options = fitting_options)</code></pre><p>To fine-tune the result with the gradient-based minimizer from above, <a href="../API/#AntibodyMethodsDoseResponse.adaptive_dose_response_fit"><code>adaptive_dose_response_fit</code></a> needs to be called again with different options (i.e. no iterations to obtain a single fit and using the offset from the previous result):</p><pre><code class="language-julia hljs">post_options = AdaptiveOptions(objective = :log_posterior, 
	offset = result.optimizer[end], 
	prior_generator = log_prior_generator
)

adaptive_result = adaptive_dose_response_fit(adaptive_result.grid,data,
		post_minimizer, 
		options = post_options
	)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AdaptiveResult(DoseResponseResult([1.0e-10, 3.414548873833601e-10, 1.1659144011798312e-9, 3.981071705534969e-9, 1.3593563908785241e-8, 4.641588833612773e-8, 1.584893192461114e-7, 5.411695265464649e-7, 1.8478497974222906e-6, 6.309573444801943e-6, 2.1544346900318823e-5, 7.356422544596421e-5, 0.0002511886431509585, 0.0008576958985908955, 0.0029286445646252404, 0.01000000000000001], [0.0002151515291751624, 0.0006921587799722355, 0.0022905029655082786, 0.007443973653780975, 0.022853144957024545, 0.06797238519943972, 0.19966295081460653, 0.49571602988005475, 0.8642379125811639, 1.0893274365958179, 1.2773452268224166, 1.6085308539628609, 1.9318598992532872, 2.0464652408184993, 2.083818824385206, 2.1279853033212195]), AdaptiveDensityApproximation.OneDimGrid{Dict{String, AdaptiveDensityApproximation.OneDimBlock}}(Dict{String, AdaptiveDensityApproximation.OneDimBlock}(&quot;3JyfIUOX6B&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;3JyfIUOX6B&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(7.424145507812504e-5, 9.865527343750006e-5), [&quot;qFUMw1vsMX&quot;, &quot;E2XXh5c0Ng&quot;], 0.16472499888424993), &quot;rujLi5QtVb&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;rujLi5QtVb&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(1.0e-11, 1.563484375e-8), [&quot;vquKmdZOGo&quot;], 0.004341001429126158), &quot;ZxffhPQV32&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;ZxffhPQV32&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(3.12596875e-8, 6.2509375e-8), [&quot;trHP4iPjpW&quot;, &quot;vquKmdZOGo&quot;], 1.727235611365988e-77), &quot;JHECggIBM8&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;JHECggIBM8&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(0.0007822421875000004, 0.0015634843750000009), [&quot;eBlfrZTAI9&quot;, &quot;Hv0Ip73RC3&quot;], 0.001501251526736913), &quot;N4fL5MvOK2&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;N4fL5MvOK2&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(5.00005e-7, 7.500025e-7), [&quot;poVc2Xv085&quot;, &quot;JbWtsGfJBi&quot;], 0.19869363240125143), &quot;wdWYqyQ8h5&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;wdWYqyQ8h5&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(1.3814659118652343e-6, 1.762931823730469e-6), [&quot;0Nkvdq5e1X&quot;, &quot;EgtC40YSEz&quot;], 0.09853321569417299), &quot;iMO3ai37cE&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;iMO3ai37cE&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(1.3206909179687506e-5, 2.5413818359375012e-5), [&quot;gMRPGbCd8X&quot;, &quot;sGYplrh1wa&quot;], 0.019068192982810157), &quot;LKhlmOvMlS&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;LKhlmOvMlS&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(3.762072753906252e-5, 4.9827636718750027e-5), [&quot;sGYplrh1wa&quot;, &quot;qFUMw1vsMX&quot;], 0.10975322269081782), &quot;sGYplrh1wa&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;sGYplrh1wa&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(2.5413818359375012e-5, 3.762072753906252e-5), [&quot;LKhlmOvMlS&quot;, &quot;iMO3ai37cE&quot;], 0.08048299314561375), &quot;bDB0qNnb9H&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;bDB0qNnb9H&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(0.0031259687500000016, 0.006250937500000003), [&quot;mvxhhAEn2R&quot;, &quot;eBlfrZTAI9&quot;], 0.0331808968368835)…)), [0.004341001429126158, 4.2168791772922093e-81, 1.727235611365988e-77, 3.074783068613537e-64, 0.01561989417632643, 0.10123508246723202, 0.11526152110184903, 0.19869363240125143, 0.14554036094467476, 0.15436608431246654  …  0.004093060419472806, 0.001501251526736913, 0.0249094597643404, 0.0331808968368835, 0.02981094997923824, 0.024666346416469635, 0.02136565728044595, 0.01171345131205015, 0.008112278353753133, 1.6356889642709812e-5], 3.320092090041977, 130.98534727096558)</code></pre><p>As before, the fitted dose-response curve describes the data well:</p><pre><code class="language-julia hljs">scatter(data, xaxis = :log, legend = :topleft, label = &quot;data&quot;)
plot!(adaptive_result.result, label = &quot;fit result&quot;, color = 3)</code></pre><img src="e37675c9.svg" alt="Example block output"/><p>But comparing the estimated densities from the simple model fit and the adaptive model reveals the difference:</p><pre><code class="language-julia hljs">plot(DensityPlot(result.grid), xaxis = :log, color = 2,
	fill = 0, fillalpha = 0.5, legend = :topleft, label = &quot;simple fit&quot;)

plot!(DensityPlot(adaptive_result.grid), color = 3,
	fill = 0, fillalpha = 0.5, label = &quot;adaptive fit&quot;)</code></pre><img src="13deccc8.svg" alt="Example block output"/><h2 id="The-same-options-in-the-convenience-workflow"><a class="docs-heading-anchor" href="#The-same-options-in-the-convenience-workflow">The same options in the convenience workflow</a><a id="The-same-options-in-the-convenience-workflow-1"></a><a class="docs-heading-anchor-permalink" href="#The-same-options-in-the-convenience-workflow" title="Permalink"></a></h2><p>As mentioned above, the convenience workflow exposes the same options as <a href="../API/#AntibodyMethodsDoseResponse.adaptive_dose_response_fit"><code>adaptive_dose_response_fit</code></a>. Although the <a href="#adaptive_model_fitting">adaptive model fitting</a> section uses options that are already the defaults of the convenience workflow, this section creates these options explicitly to illustrate how to modify the options and to illustrate the convenience gain.</p><p>First, the log-prior-generator (with the scale <code>500</code>) can be obtained with <a href="../API_Convenience/#AntibodyMethodsDoseResponseConvenience.scaled_log_volume_prior"><code>scaled_log_volume_prior</code></a>:</p><pre><code class="language-julia hljs">log_prior_generator = scaled_log_volume_prior(500)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">#1 (generic function with 1 method)</code></pre><p>The <a href="https://translational-pain-research.github.io/FittingObjectiveFunctions-documentation/API/#FittingObjectiveFunctions.FittingData"><code>FittingData</code></a> object is created as before.</p><pre><code class="language-julia hljs">data = FittingData(concentrations,responses, errors, distributions = (y,m,Δy)-&gt; -(y-m)^2/Δy^2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">FittingData([1.0e-10, 3.414548873833601e-10, 1.1659144011798312e-9, 3.981071705534969e-9, 1.3593563908785241e-8, 4.641588833612773e-8, 1.584893192461114e-7, 5.411695265464649e-7, 1.8478497974222906e-6, 6.309573444801943e-6, 2.1544346900318823e-5, 7.356422544596421e-5, 0.0002511886431509585, 0.0008576958985908955, 0.0029286445646252404, 0.01000000000000001], [0.00021410640885032888, 0.0007663741382536124, 0.0022904228427114396, 0.007480511858978876, 0.02234921802107462, 0.06800642522811402, 0.1999605075743781, 0.48627646991166545, 0.8640377791882656, 1.1066809652565421, 1.2718676867480627, 1.5954463405164325, 2.0827667975228743, 2.038420572824142, 2.129076978959971, 2.12713266152728], [9.038975931520719e-6, 7.48542293064205e-5, 0.0001715062199824497, 0.0006347118571287526, 0.0009298400467954249, 0.0034907971363670695, 0.002630265790858374, 0.04611199595837917, 0.014791696364573545, 0.06862939569552252, 0.03683894761707063, 0.09538214293549667, 0.15611494403288997, 0.03885184183872844, 0.146064853827133, 0.04829619497432603], Function[Main.var&quot;#1#2&quot;(), Main.var&quot;#1#2&quot;(), Main.var&quot;#1#2&quot;(), Main.var&quot;#1#2&quot;(), Main.var&quot;#1#2&quot;(), Main.var&quot;#1#2&quot;(), Main.var&quot;#1#2&quot;(), Main.var&quot;#1#2&quot;(), Main.var&quot;#1#2&quot;(), Main.var&quot;#1#2&quot;(), Main.var&quot;#1#2&quot;(), Main.var&quot;#1#2&quot;(), Main.var&quot;#1#2&quot;(), Main.var&quot;#1#2&quot;(), Main.var&quot;#1#2&quot;(), Main.var&quot;#1#2&quot;()])</code></pre><p>The <code>Optim.jl</code> minimizers can be obtained with less boilerplate code, using <a href="../API_Convenience/#AntibodyMethodsDoseResponseConvenience.minimizer_generator"><code>minimizer_generator</code></a>:</p><pre><code class="language-julia hljs">minimizer = minimizer_generator(NelderMead())
post_minimizer = minimizer_generator(LBFGS())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">#12 (generic function with 1 method)</code></pre><p>In general, the grid is created automatically, based on the concentration range of the dose-response data. However, if one concentration is <code>0</code>, the automatic grid should not be used.</p><pre><code class="language-julia hljs">grid = create_grid(LogRange(1e-10,1e-2,3))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AdaptiveDensityApproximation.OneDimGrid{Dict{String, AdaptiveDensityApproximation.OneDimBlock}}(Dict{String, AdaptiveDensityApproximation.OneDimBlock}(&quot;gCx8gXCWGR&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;gCx8gXCWGR&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(1.0e-10, 1.0e-6), [&quot;7HYaQSnsls&quot;], 1.0), &quot;7HYaQSnsls&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;7HYaQSnsls&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(1.0e-6, 0.01000000000000001), [&quot;gCx8gXCWGR&quot;], 1.0)))</code></pre><div class="admonition is-info"><header class="admonition-header">automatic grids and the zero concentration</header><div class="admonition-body"><p>The automatic grids are created with the <a href="../API/#AntibodyMethodsDoseResponse.LogRange"><code>LogRange</code></a> function and are intended for logarithmic plots. A zero-concentration would lead to a <code>DomainError</code>, as <a href="../API/#AntibodyMethodsDoseResponse.LogRange"><code>LogRange</code></a> demands positive numbers. To avoid an error, the automatic grid generator then substitutes <code>eps()</code> for <code>0</code> (only for the auto-generated grid) and raise a warning. However, too large grid domains lead to poor fit results. Hence, it is recommended to create the grid manually in those cases.</p></div></div><p>The same options as before are used:</p><pre><code class="language-julia hljs">adaptive_options = AdaptiveOptions(objective = :log_posterior, iterations = 30,
			offset = eps(), prior_generator = log_prior_generator)

post_options = AdaptiveOptions(objective = :log_posterior, offset = eps(),
			prior_generator = log_prior_generator)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AdaptiveOptions(&quot;Adaptive optimization&quot;, true, 1, AntibodyMethodsDoseResponse.accumulation_model, 2.220446049250313e-16, :log_posterior, AntibodyMethodsDoseResponseConvenience.var&quot;#1#6&quot;{Int64}(500), nothing, AntibodyMethodsDoseResponse.default_prior_gradient_generator, AntibodyMethodsDoseResponse.log_area_scaled_variation, maximum)</code></pre><p>Finally, the objects, functions and options from above need to be summarized in a <a href="../API_Convenience/#AntibodyMethodsDoseResponseConvenience.FittingCondition"><code>FittingCondition</code></a> object:</p><pre><code class="language-julia hljs">condition = FittingCondition(data,
	grid = grid,
	options_1 = adaptive_options,
	options_2 = post_options,
	minimizer_1 = minimizer,
	minimizer_2 = post_minimizer
	)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">FittingCondition(FittingData([1.0e-10, 3.414548873833601e-10, 1.1659144011798312e-9, 3.981071705534969e-9, 1.3593563908785241e-8, 4.641588833612773e-8, 1.584893192461114e-7, 5.411695265464649e-7, 1.8478497974222906e-6, 6.309573444801943e-6, 2.1544346900318823e-5, 7.356422544596421e-5, 0.0002511886431509585, 0.0008576958985908955, 0.0029286445646252404, 0.01000000000000001], [0.00021410640885032888, 0.0007663741382536124, 0.0022904228427114396, 0.007480511858978876, 0.02234921802107462, 0.06800642522811402, 0.1999605075743781, 0.48627646991166545, 0.8640377791882656, 1.1066809652565421, 1.2718676867480627, 1.5954463405164325, 2.0827667975228743, 2.038420572824142, 2.129076978959971, 2.12713266152728], [9.038975931520719e-6, 7.48542293064205e-5, 0.0001715062199824497, 0.0006347118571287526, 0.0009298400467954249, 0.0034907971363670695, 0.002630265790858374, 0.04611199595837917, 0.014791696364573545, 0.06862939569552252, 0.03683894761707063, 0.09538214293549667, 0.15611494403288997, 0.03885184183872844, 0.146064853827133, 0.04829619497432603], Function[Main.var&quot;#1#2&quot;(), Main.var&quot;#1#2&quot;(), Main.var&quot;#1#2&quot;(), Main.var&quot;#1#2&quot;(), Main.var&quot;#1#2&quot;(), Main.var&quot;#1#2&quot;(), Main.var&quot;#1#2&quot;(), Main.var&quot;#1#2&quot;(), Main.var&quot;#1#2&quot;(), Main.var&quot;#1#2&quot;(), Main.var&quot;#1#2&quot;(), Main.var&quot;#1#2&quot;(), Main.var&quot;#1#2&quot;(), Main.var&quot;#1#2&quot;(), Main.var&quot;#1#2&quot;(), Main.var&quot;#1#2&quot;()]), nothing, AdaptiveDensityApproximation.OneDimGrid{Dict{String, AdaptiveDensityApproximation.OneDimBlock}}(Dict{String, AdaptiveDensityApproximation.OneDimBlock}(&quot;gCx8gXCWGR&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;gCx8gXCWGR&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(1.0e-10, 1.0e-6), [&quot;7HYaQSnsls&quot;], 1.0), &quot;7HYaQSnsls&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;7HYaQSnsls&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(1.0e-6, 0.01000000000000001), [&quot;gCx8gXCWGR&quot;], 1.0))), &quot;&quot;, AdaptiveOptions(&quot;Adaptive optimization&quot;, true, 30, AntibodyMethodsDoseResponse.accumulation_model, 2.220446049250313e-16, :log_posterior, AntibodyMethodsDoseResponseConvenience.var&quot;#1#6&quot;{Int64}(500), nothing, AntibodyMethodsDoseResponse.default_prior_gradient_generator, AntibodyMethodsDoseResponse.log_area_scaled_variation, maximum), AdaptiveOptions(&quot;Adaptive optimization&quot;, true, 1, AntibodyMethodsDoseResponse.accumulation_model, 2.220446049250313e-16, :log_posterior, AntibodyMethodsDoseResponseConvenience.var&quot;#1#6&quot;{Int64}(500), nothing, AntibodyMethodsDoseResponse.default_prior_gradient_generator, AntibodyMethodsDoseResponse.log_area_scaled_variation, maximum), AntibodyMethodsDoseResponseConvenience.var&quot;#12#14&quot;{Optim.Options{Float64, Nothing}, NelderMead{Optim.AffineSimplexer, Optim.AdaptiveParameters}}(Optim.Options(x_abstol = 0.0, x_reltol = 0.0, f_abstol = 0.0, f_reltol = 0.0, g_abstol = 1.0e-12, g_reltol = 1.0e-8, outer_x_abstol = 0.0, outer_x_reltol = 0.0, outer_f_abstol = 0.0, outer_f_reltol = 0.0, outer_g_abstol = 1.0e-8, outer_g_reltol = 1.0e-8, f_calls_limit = 0, g_calls_limit = 0, h_calls_limit = 0, allow_f_increases = true, allow_outer_f_increases = true, successive_f_tol = 1, iterations = 2000, outer_iterations = 1000, store_trace = false, trace_simplex = false, show_trace = false, extended_trace = false, show_warnings = true, show_every = 1, time_limit = NaN, )
, NelderMead{Optim.AffineSimplexer, Optim.AdaptiveParameters}(Optim.AffineSimplexer(0.025, 0.5), Optim.AdaptiveParameters(1.0, 1.0, 0.75, 1.0))), AntibodyMethodsDoseResponseConvenience.var&quot;#12#14&quot;{Optim.Options{Float64, Nothing}, LBFGS{Nothing, InitialStatic{Float64}, HagerZhang{Float64, Base.RefValue{Bool}}, Optim.var&quot;#19#21&quot;}}(Optim.Options(x_abstol = 0.0, x_reltol = 0.0, f_abstol = 0.0, f_reltol = 0.0, g_abstol = 1.0e-12, g_reltol = 1.0e-8, outer_x_abstol = 0.0, outer_x_reltol = 0.0, outer_f_abstol = 0.0, outer_f_reltol = 0.0, outer_g_abstol = 1.0e-8, outer_g_reltol = 1.0e-8, f_calls_limit = 0, g_calls_limit = 0, h_calls_limit = 0, allow_f_increases = true, allow_outer_f_increases = true, successive_f_tol = 1, iterations = 2000, outer_iterations = 1000, store_trace = false, trace_simplex = false, show_trace = false, extended_trace = false, show_warnings = true, show_every = 1, time_limit = NaN, )
, LBFGS{Nothing, InitialStatic{Float64}, HagerZhang{Float64, Base.RefValue{Bool}}, Optim.var&quot;#19#21&quot;}(10, InitialStatic{Float64}
  alpha: Float64 1.0
  scaled: Bool false
, HagerZhang{Float64, Base.RefValue{Bool}}
  delta: Float64 0.1
  sigma: Float64 0.9
  alphamax: Float64 Inf
  rho: Float64 5.0
  epsilon: Float64 1.0e-6
  gamma: Float64 0.66
  linesearchmax: Int64 50
  psi3: Float64 0.1
  display: Int64 0
  mayterminate: Base.RefValue{Bool}
  cache: Nothing nothing
, nothing, Optim.var&quot;#19#21&quot;(), Flat(), true)), nothing)</code></pre><p>Fitting the <code>condition</code> is done by calling <a href="../API_Convenience/#AntibodyMethodsDoseResponseConvenience.fit_condition"><code>fit_condition</code></a>:</p><pre><code class="language-julia hljs">result = fit_condition(condition)
plot(DensityPlot(result.grid), xaxis = :log, fill = 0, fillalpha = 0.5)</code></pre><img src="79b252c1.svg" alt="Example block output"/><h2 id="Multi-threaded-fitting"><a class="docs-heading-anchor" href="#Multi-threaded-fitting">Multi-threaded fitting</a><a id="Multi-threaded-fitting-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-threaded-fitting" title="Permalink"></a></h2><p>The fitting of a single condition cannot be parallelized. However, fitting more than one condition can be done in parallel. Consider an array of <a href="../API_Convenience/#AntibodyMethodsDoseResponseConvenience.FittingCondition"><code>FittingCondition</code></a> objects:</p><pre><code class="language-julia hljs">conditions = [condition_1,condition_2,condition_3]</code></pre><p>The conditions can be fitted in parallel with <a href="../API_Convenience/#AntibodyMethodsDoseResponseConvenience.fit_conditions"><code>fit_conditions</code></a> (observe the additional <code>s</code>):</p><pre><code class="language-julia hljs">fit_conditions(conditions)</code></pre><div class="admonition is-info"><header class="admonition-header">Multi-threading</header><div class="admonition-body"><p>The number of threads cannot be changed after Julia is launched. The number of threads needs to be set in before, e.g. with <code>julia -t 8</code> to run Julia with 8 threads. The number of threads can be checked with <code>Threads.nthreads()</code>.</p></div></div><h2 id="Changing-the-initial-values"><a class="docs-heading-anchor" href="#Changing-the-initial-values">Changing the initial values</a><a id="Changing-the-initial-values-1"></a><a class="docs-heading-anchor-permalink" href="#Changing-the-initial-values" title="Permalink"></a></h2><p>In each case discussed here, no initial parameter values were set for the model fitting. This is, because the wights of the gird are used as initial values. By default, <a href="https://translational-pain-research.github.io/AdaptiveDensityApproximation-documentation/api/#AdaptiveDensityApproximation.create_grid"><code>create_grid</code></a> sets all weights to <code>1</code>:</p><pre><code class="language-julia hljs">grid = create_grid(LogRange(1e-10,1e-2,3))
export_weights(grid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Float64}:
 1.0
 1.0</code></pre><p>Changing the weights of the gird before running the fitting-process allows to specify the initial values for the model fitting. E.g. for the manual definition of adaptive fitting:</p><pre><code class="language-julia hljs">import_weights!(grid,[eps(),1])
adaptive_result = adaptive_dose_response_fit(grid,data,minimizer, options = fitting_options)</code></pre><p>Or for the convenience workflow, e.g. after the <code>FittingCondition</code> has already been defined:</p><pre><code class="language-julia hljs">import_weights!(condition.grid,[eps(),1])
result = fit_condition(condition)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../DensityPlots/">« Density plots for <code>OneDimGrid</code></a><a class="docs-footer-nextpage" href="../Uncertainty/">Uncertainty estimation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Thursday 12 September 2024 16:02">Thursday 12 September 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
