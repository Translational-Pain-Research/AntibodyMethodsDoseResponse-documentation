var documenterSearchIndex = {"docs":
[{"location":"Models/#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"Models/#binding_models","page":"Models","title":"Binding models","text":"","category":"section"},{"location":"Models/","page":"Models","title":"Models","text":"Two binding model kernels are available:","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"textAccumulationquad  x(a) = g(1-e^-fracaK_tau)qquad textandqquad textLangmuir isothermquad x(a) = fracg1+fracK_da","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"The Langmuir isotherm describes the equilibrium of binding (with rate k_texton) and unbinding (with rate k_textoff) of antibodies, which is characterized by the dissociation constant K_d = frack_textoffk_texton.\nThe accumulation model describes the accumulation of antibodies (with rate k_texton) during the incubation time tau, which is characterized by the accessibility constant K_tau = frac1k_textoncdot tau.","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"tip: Jovanovic isotherm\nThe accumulation model resembles the Jovanovic isotherm structurally. However, the Jovanovic isotherm describes an equilibrium of binding and unbinding processes, whereas the accumulation model describes the accumulation over time, which is stopped at a finite time tau before reaching the saturation. Nevertheless, because of the structural similarity, the accumulation model can be used as drop-in replacement to analyze equilibrium data with the Jovanovic isotherm.","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"Both model kernels are used for the rate constant distribution approach (Svitel et al. 2003):","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"beginaligned\ntextAccumulation model quad x(a) = int_0^infty g(k)(1-e^-fracak) dk\ntextLangmuir model quad  x(a) = int_0^infty fracg(k)1+fracka  dk \nendaligned","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"In both cases, the density g(k) describes the number of epitopes that exhibit the respective constant k (accessibility / affinity depending on the model). The density approach models the superposition of different classes of epitopes being present in the system at the same time (e.g. in complex cellular systems).","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"info: Default model\nThe accumulation model is set as default model for all methods in this package. Accordingly this documentation describes most terms, results, interpretations from the perspective of the accumulation model.","category":"page"},{"location":"Models/#Integral-approximation","page":"Models","title":"Integral approximation","text":"","category":"section"},{"location":"Models/","page":"Models","title":"Models","text":"The analysis of dose-response data with the models above essentially means the estimation of the density g(k) from the dose-response data. To simplify the inference problem, g(k) is approximated by a sum of constant functions over a disjunct set of intervals I_j_j=1^m:","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"g(k) approx sum_j=1^m g_j cdot chi_I_j(x) qquad textwith qquad chi_I_j(x) = left beginarrayll 1    x in I_j 0   textelse endarray right","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"With this approximation, the accumulation model becomes:","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"x(a) approx sum_j=1^m g_j int_I_j(1-e^-fracak) dk ","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"Thus, the inference problem is the estimation of the parameters g_1ldots g_m.","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"The intervals I_j and the weights g_j are implemented as one-dimensional grid with AdaptiveDensityApproximation.jl.","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"using AntibodyMethodsDoseResponseConvenience #hide\nusing AdaptiveDensityApproximation\ngrid = create_grid([1,2,3,5])","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"The example above created a grid corresponding to the intervals 122335 with weights g_j = 1.  To view the grid properties, AdaptiveDensityApproximationRecipes.jl can be used:","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"using AdaptiveDensityApproximationRecipes, Plots\nplot(grid)","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"New weights can be set with import_weights!:","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"import_weights!(grid, [1,2,0.5])\nplot(grid)","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"When the intervals have different lengths, the overall impact of the weights g_j becomes skewed, since the term int_I_j(1-e^-fracak) dk depends on the interval length. For the estimation of parameters it can be beneficial to use length-normalized parameters:","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"g_j = fraclambda_jtextlength(I_j)","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"In other words, while g_j is the density value, lambda_j is the number of epitopes with K_tauin I_j.","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"Finally, the analytical solution of int_I_j(1-e^-fracak) dk requires the exponential integral function, not implemented in Julia Base. To avoid additional dependencies, this integral is approximated by","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"int_I_j(1-e^-fracak) dk approx textlength(I_j) cdot (1-e^-fracatextcenter(I_j))","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"Rightarrow quad x(a) approx sum_j=1^m g_j int_I_j(1-e^-fracak) dk approx sum_j=1^m g_j cdot textlength(I_j) cdot (1-e^-fracatextcenter(I_j)) = sum_j=1^m lambda_j cdot (1-e^-fracatextcenter(I_j))","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"info: Weights of the grid\nThe weights of OneDimGrid objects are always treated as lambda_j for the analysis of dose-response data. Thus, the weights describe the number of epitopes with K_tau in the given interval, not the K_tau-density value!","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"remark: Inverse constant\nTo solve the integrals analytically, the inverse constant widetildeK = frac1K_tau can be used: int (1-e^-acdot widetildek)  d widetildek = frace^-acdot widetildeka + widetildek + textconstant While the use of the inverse constant does not change the discrete superposition (countable sum), the integral approximation uses a different  density widetildeg if the inverse constant is used.","category":"page"},{"location":"Models/#Obtain-model-functions","page":"Models","title":"Obtain model functions","text":"","category":"section"},{"location":"Models/","page":"Models","title":"Models","text":"Having specified the intervals with a grid, the model function can be obtained with the following model generators: accumulation_model, langmuir_model, accumulation_inv_const_model and langmuir_inv_const_model.","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"model, init_params, centers, volumes = accumulation_model(grid, offset = 10) \nnothing #hide","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"model is a ModelFunctions object from FittingObjectiveFunctions.jl, containing both the model function and the partial derivatives w.r.t. to the parameters.","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"init_params contains the weights of the grid, and as last element the offset if offset != nothing:","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"println(init_params)","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"centers contains the center points of the intervals of the grid:","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"println(centers)","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"and volumes contains the lengths of the intervals of the grid:","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"println(volumes)","category":"page"},{"location":"Models/#Tips-for-girds","page":"Models","title":"Tips for girds","text":"","category":"section"},{"location":"Models/","page":"Models","title":"Models","text":"Choosing unequal interval sizes in the example above was not just for demonstration purposes. In fact, a rule of thumb for the K_tau domain is to use the concentration/dilution range of the dose-response curve, which often spans multiple orders of magnitude. Consider for example the domain 10^-810^-2:","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"plot(create_grid(LinRange(1e-8,1e-2,50)))","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"In a linear scale, this interval discretization seems to resolve the domain well enough. But plotting the same grid in a logarithmic scale leads to:","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"plot(create_grid(LinRange(1e-8,1e-2,50)), xaxis = :log, xticks = [10.0^-i for i in 2:8])","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"Equally sized intervals poorly resolve the smaller orders of magnitude. A single interval covers the domain 10^-810^-4, while almost all intervals subdivide the domain 10^-310^-2. A solution for this problem is to use logarithmically sized intervals:","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"plot(create_grid(LogRange(1e-8,1e-2,50)), xaxis = :log, xticks = [10.0^-i for i in 2:8])","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"tip: LogRange\nJulia provides the LinRange function to create equally spaced points in a given range. AntibodyMethodsDoseResponse.jl adds LogRange to create logarithmically spaced points in a given range, following the same general syntax: LogRange(start, stop, n_points, [base = 10]).","category":"page"},{"location":"ResultsAndSimulations/#Results-and-Simulations","page":"Results and simulations","title":"Results and Simulations","text":"","category":"section"},{"location":"ResultsAndSimulations/#Why-OneDimGrid-objects?","page":"Results and simulations","title":"Why OneDimGrid objects?","text":"","category":"section"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"The model generator requires a OneDimGrid objects from AdaptiveDensityApproximation.jl (see Models). For this, the actual weights of the grid do not matter. The model generator returns a new parameter array and a corresponding model function. It is possible to set parameter values in this array and to simulate dose-response curves with the corresponding, returned model function.","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"But AdaptiveDensityApproximation.jl offers additional methods, e.g. the name-giving adaptive approximation of densities or additional density conversion / analysis tools. For this reason, internal methods use OneDimGrid objects and construct the model functions from scratch for the calculation of dose-response curves. This is, among others, the reason why most functions (e.g. the convenience functions of AntibodyMethodsDoseResponseConvenience) return or expect those grids. ","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"tip: Tip\nAlthough not necessary for all analyses, it is highly recommended to use the OneDimGrid workflow, as advanced methods of this package will expect grids.","category":"page"},{"location":"ResultsAndSimulations/#Simulating-the-K_\\tau-density","page":"Results and simulations","title":"Simulating the K_tau-density","text":"","category":"section"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"To simulate a dose-response curve with a binding model, a density g(K_tau) needs to be defined. This can be done with any Julia function, e.g. a probability density function:","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"using AntibodyMethodsDoseResponseConvenience\nusing Distributions\n\np(x) = pdf(Normal(1e-5,3e-6),x)\nplot(p, xaxis = :log, xlims = [1e-10,1e-2], fill = 0, label = \"density\")","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"The plot function can be used without importing Plots.jl here, as AntibodyMethodsDoseResponseConvenience does this in the background automatically.","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"Next, a OndDimGrid needs to be defined to approximate the density:","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"grid = create_grid(LogRange(1e-10,1e-2,50))\napproximate_density!(grid, p, volume_normalization = true)","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"info: volume_normalization = true\nWithout volume_normalization = true (the default), the density function itself is approximated (e.g. by using the function values at the centers of the respective intervals). The volume normalization approximates the area under the curve by using function value × interval length, which in this case corresponds to the number of epitopes with K_tau in the respective interval. This is the correct choice for simulations, as the weights of grids are assumed ot be the numbers of epitopes and not the density values.","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"To inspect the grid, the plotting recipe from AdaptiveDensityApproximationRecipes.jl can be used (as described in Models):","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"using AdaptiveDensityApproximationRecipes\nplot(grid, xaxis = :log)","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"info: y-axis scale\nSince the grid approximates the area under the density curve (weights correspond to the height of the bars), the scale of the y-axis is different, compared to the density plot.","category":"page"},{"location":"ResultsAndSimulations/#Simulating-the-dose-response-curve","page":"Results and simulations","title":"Simulating the dose-response curve","text":"","category":"section"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"With the OneDimeGrid object grid, a dose-response can be simulated, using DoseResponseResult:","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"concentrations = LogRange(1e-8,1e-2,16)\n\nsimulation_result = DoseResponseResult(grid,concentrations; \n\t\t\tmodel = accumulation_model, \n\t\t\toffset = 0\n\t\t)\n\nscatter(simulation_result, xaxis = :log)","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"info: DoseResponseResult\nDoseResponseResult objects are used to construct and store dose-response curves, resulting from grids. This can be either because a grid was used to simulate a K_tau-density or because the result of a model-fit was stored in a grid. The package AntibodyMethodsDoseResponseRecipes.jl provides a plotting recipe for DoseResponseResult objects.","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"tip: filter_zeros\nThe same filter_zeros keyword that is used for FittingData plots can also be used for DoseResponseResult plots (see Measurement Data plotting).","category":"page"},{"location":"ResultsAndSimulations/#Importing-fitting-results","page":"Results and simulations","title":"Importing fitting results","text":"","category":"section"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"Instead of simulating a dose-response curve, the OneDimGrid and DoseResponseResult types can also be used to create dose-response curves from a fitting result. Since no data has been fitted yet, we construct a result from the weights of the simulation grid above:","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"parameters = export_weights(grid)\npush!(parameters, 0.2) # Add offset parameter","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"We assume now, that the gird was used to obtain the model function and that the parameters are the result of the model fit. In this case, the offset keyword was used. To import the result into the grid, the import_weights! functions can be used:","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"import_weights!(grid, parameters[1:end-1])","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"info: Why end-1 ?\nSince the offset keyword was used for the creation of model functions (in our scenario), the parameters array has one additional element at the end, the offset, which does not belong to the grid. If no offset is used, all parameters should be imported:import_weights!(grid, parameters)In fact, using the wrong selection of parameters usually leads to a DimensionMismatch error, as the number of parameters and the number of intervals in the grid do not match.","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"import_weights!(grid, parameters) # Wrong parameter selection should fail.","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"After importing the parameters into the grid, the dose-response curve can be constructed as before (for any concentrations, not only the data concentrations):","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"concentrations = LogRange(1e-8,1e-2,16)\n\nresult = DoseResponseResult(grid,concentrations; \n\t\t\tmodel = accumulation_model, \n\t\t\toffset = parameters[end]\n\t\t)\n\nscatter(result, xaxis = :log, ylims = [0,1.4])","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"Observe the offset = parameters[end] part at the end of the DoseResponseResult call. In our scenario, the parameters array contains the offset as last element.","category":"page"},{"location":"API_Convenience/#api_convenience","page":"AntibodyMethodsDoseResponseConvenience","title":"API - Convenience package","text":"","category":"section"},{"location":"API_Convenience/#Fitting-data","page":"AntibodyMethodsDoseResponseConvenience","title":"Fitting data","text":"","category":"section"},{"location":"API_Convenience/","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience","text":"scaled_log_volume_prior","category":"page"},{"location":"API_Convenience/#AntibodyMethodsDoseResponseConvenience.scaled_log_volume_prior","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience.scaled_log_volume_prior","text":"scaled_log_volume_prior(scale::Real = 1)\n\nCreate a prior generator (see AdaptiveOptions) that generates the following prior:\n\ntextprior(lambda) = - fractextscaletextlength(λ)^2 cdot left( textoffset^2 + sum_i=2^textlength(lambda) left(fraclambda_i-1log_10(r_i-1)-log_10(l_i-1) - fraclambda_ilog_10(r_i)-log_10(l_i)right)^2 right)\n\nwhere l_ir_i are the intervals corresponding to lambda_i.\n\n\n\n\n\n","category":"function"},{"location":"API_Convenience/","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience","text":"minimizer_generator","category":"page"},{"location":"API_Convenience/#AntibodyMethodsDoseResponseConvenience.minimizer_generator","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience.minimizer_generator","text":"minimizer_generator(optim_minimizer; \n\toptions = Optim.Options(g_tol = 1e-12, iterations = 2000), \n\tgradient::Bool = false\n)\n\nCreate a minimization function (f,∇f,initial_point) -> minimizing_point as specified in adaptive_dose_response_fit, using minimizers from Optim.jl (e.g. NelderMead() or LBFGS()).\n\nIf gradient = false, the gradient function ∇f is ignored, useful e.g. for adaptive_dose_response_fit where ∇f = nothing is internally passed as argument in some cases.\n\nExamples\n\nminimizer_generator(NelderMead())\n\nminimizer_generator(LBFGS(), \n\toptions = Optim.Options(g_tol = 1e-6, iterations = 400), \n\tgradient = true\n)\n\n\n\n\n\n","category":"function"},{"location":"API_Convenience/","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience","text":"FittingCondition","category":"page"},{"location":"API_Convenience/#AntibodyMethodsDoseResponseConvenience.FittingCondition","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience.FittingCondition","text":"mutable struct FittingCondition\n\nData type storing the necessary information for the common workflow of adaptive_dose_response_fit. Convenience constructors with recommended options are implemented. Note that all objects are \"deepcopied\" to avoid unwanted mutation.\n\nFields\n\ndata: The FittingData object containing the dose-response data.\nreplicates: Vector of FittingData objects that constitute the replicates of measured dose-response curves.\ngrid: Initial K_τ grid that is adaptively refined.\npath: Fitting results are saved to path if path != \"\".\noptions_1: AdaptiveOptions for the first run of adaptive_dose_response_fit.\noptions_2: AdaptiveOptions for a second run of adaptive_dose_response_fit, e.g. to use a final, non-adaptive, gradient-based fit.\nminimizer_1: Minimization function for the first run of adaptive_dose_response_fit.\nminimizer_2: Minimization function for the second run of adaptive_dose_response_fit.\nresult_concentrations: Concentrations to be used for the dose-response curve calculated from the fit result. This allows to obtain smooth result curves. If result_concentrations = nothing, the concentrations of data are used.\n\nConvenience constructors\n\nFittingCondition(data::FittingData, replicates = nothing; keywords...)\n\nManual specification of the FittingData object and the optional replicates. Recommended fitting options are predefined and path=\"\" is set to avoid accidental creation of files. \n\nFittingCondition(concentrations::AbstractVector, response_replicates::AbstractVector...; \n\tkeywords...)\n\nConstruct a FittingCondition from a concentration vector and response vectors (variable number of arguments). This automatically creates the main FittingData object, and the vector of FittingData objects for the replicates.\n\nThe main FittingData object uses the mean values of the responses together with the standard deviations as uncertainties. The uncertainty distributions are unnormalized logarithmic normal distributions:\n\n(y,m,Δy)-> -(y-m)^2/Δy^2\n\nKeywords\n\nThe keywords correspond to the struct fields, except for the additional scale keyword. Setting scale overwrites the objective field to :log_posterior and the prior_generator field to scaled_log_volume_prior for both options: options_1 and options_2.\n\nThe keyword defaults are:\n\ngrid = create_grid(LogRange(extrema(concentrations)...,3))\npath = \"\"\noptions_1 = AdaptiveOptions(objective = :lsq, offset = eps(), iterations = 30)\noptions_2 = AdaptiveOptions(objective = :lsq, offset = eps())\nminimizer_1 = minimizer_generator(NelderMead())\nminimizer_2 = minimizer_generator(LBFGS())\nresult_concentrations = nothing\nscale = nothing\n\n\n\n\n\n","category":"type"},{"location":"API_Convenience/","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience","text":"fit_condition","category":"page"},{"location":"API_Convenience/#AntibodyMethodsDoseResponseConvenience.fit_condition","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience.fit_condition","text":"fit_condition(condition::FittingCondition)\n\nObtain the results for a FittingCondition object (i.e. fitting the data).\n\nReturns the AdaptiveResult object and saves the data (FittingCondition and AdaptiveResult objects) to FittingCondition.path if not FittingCondition.path = \"\".\n\n\n\n\n\n","category":"function"},{"location":"API_Convenience/","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience","text":"fit_conditions","category":"page"},{"location":"API_Convenience/#AntibodyMethodsDoseResponseConvenience.fit_conditions","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience.fit_conditions","text":"fit_conditions(conditions)\n\nMultithreaded application of fit_condition to a collection of FittingCondition objects (conditions).\n\n\n\n\n\n","category":"function"},{"location":"API_Convenience/#Loading-data","page":"AntibodyMethodsDoseResponseConvenience","title":"Loading data","text":"","category":"section"},{"location":"API_Convenience/","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience","text":"load_results","category":"page"},{"location":"API_Convenience/#AntibodyMethodsDoseResponseConvenience.load_results","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience.load_results","text":"load_results(path::AbstractString)\n\nLoad results and data as saved by fit_condition. Returns (result, data,replicates) as AdaptiveResult, FittingData and vector of FittingData objects.\n\n\n\n\n\n","category":"function"},{"location":"API_Convenience/#Modify-default-plotting-options","page":"AntibodyMethodsDoseResponseConvenience","title":"Modify default plotting options","text":"","category":"section"},{"location":"API_Convenience/","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience","text":"info: Info\nIn the plotting functions, the default options are not defined as tuples of keyword arguments, but as function calls. The following functions generate the default keyword arguments, but allow to selectively change individual keywords or pass new Plots.jl keywords. In this way, changing the keywords does not require to manually repeat the unchanged default keyword arguments.","category":"page"},{"location":"API_Convenience/","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience","text":"dr_base_plot","category":"page"},{"location":"API_Convenience/#AntibodyMethodsDoseResponseConvenience.dr_base_plot","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience.dr_base_plot","text":"function dr_base_plot(keywords...)\n\nFunction to return a modified dose-response base plot. Most Plots.jl keywords are available. By default, the following keyword arguments are set:\n\nxaxis = :log\nxlabel = \"dilution\"\nylabel = \"response\"\nlegend = :topleft\ndensity = 300\n\n\n\n\n\n","category":"function"},{"location":"API_Convenience/","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience","text":"density_base_plot","category":"page"},{"location":"API_Convenience/#AntibodyMethodsDoseResponseConvenience.density_base_plot","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience.density_base_plot","text":"density_base_plot(keywords...)\n\nFunction to return a modified K_τ density base plot. Most Plots.jl keywords are available. By default, the following keyword arguments are set:\n\nxaxis = :log\nxlabel = \"K_τ\"\nylabel = \"density\"\nlegend = :topleft\ndensity = 300\n\n\n\n\n\n","category":"function"},{"location":"API_Convenience/","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience","text":"data_options","category":"page"},{"location":"API_Convenience/#AntibodyMethodsDoseResponseConvenience.data_options","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience.data_options","text":"data_options(keywords...)\n\nFunction to return a modified tuple of plotting keyword arguments for the FittingData object. Most Plots.jl keywords are available. By default, the following keyword arguments are set:\n\nseriestype = :scatter\ncolor = 1\nlabel = \"mean values\"\nyerrors = nothing\n\nIn addition, the following keyword ia available:\n\nfilter_zeros = [true,false]: Select to omit data points from the plot when the x-value is zero (if true for first element of filter_zeros) or the y-value is zero (if true for second element of filter_zeros). See Measurement data - Plotting for further information.\n\n\n\n\n\n","category":"function"},{"location":"API_Convenience/","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience","text":"replicate_options","category":"page"},{"location":"API_Convenience/#AntibodyMethodsDoseResponseConvenience.replicate_options","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience.replicate_options","text":"replicate_options(keywords...)\n\nFunction to return a modified tuple of plotting keyword arguments for the replicate data. Most Plots.jl keywords are available. By default, the following keyword arguments are set:\n\nseriestype = :scatter\ncolor = :black\nopacity = 0.2\nlabel = \"replicates\"\nyerrors = nothing\n\nIn addition, the following keyword ia available:\n\nfilter_zeros = [true,false]: Select to omit data points from the plot when the x-value is zero (if true for first element of filter_zeros) or the y-value is zero (if true for second element of filter_zeros). See Measurement data - Plotting for further information.\n\n\n\n\n\n","category":"function"},{"location":"API_Convenience/","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience","text":"fit_options","category":"page"},{"location":"API_Convenience/#AntibodyMethodsDoseResponseConvenience.fit_options","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience.fit_options","text":"fit_options(keywords...)\n\nFunction to return a modified tuple of plotting keyword arguments for the DoseResponseResult response curve. Most Plots.jl keywords are available. By default, the following keyword arguments are set:\n\nseriestype = :path\ncolor = 2\nlabel = \"fit result\"\n\nIn addition, the following keyword ia available:\n\nfilter_zeros = [true,false]: Select to omit data points from the plot when the x-value is zero (if true for first element of filter_zeros) or the y-value is zero (if true for second element of filter_zeros). See Measurement data - Plotting for further information.\n\n\n\n\n\n","category":"function"},{"location":"API_Convenience/","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience","text":"density_options","category":"page"},{"location":"API_Convenience/#AntibodyMethodsDoseResponseConvenience.density_options","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience.density_options","text":"density_options(keywords...)\n\nFunction to return a modified tuple of plotting keyword arguments for the DoseResponseResult density. Most Plots.jl keywords are available. By default, the following keyword arguments are set:\n\nseriestype = :path\ncolor = 2\n`fillalpha = 0.5\nlabel = \"fitted density\"\n\nIn addition, the following keyword ia available:\n\nvolume_normalization = :log: Normalizes the grid weights for plotting. If :none the weights are not normalized, if :linear the weights are divided by their corresponding interval length and if :log the weights are divided by the interval length as it appears in a logarithmic plot. See Background: log-volume normalization for further information.\n\n\n\n\n\n","category":"function"},{"location":"API_Convenience/","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience","text":"eu_options","category":"page"},{"location":"API_Convenience/#AntibodyMethodsDoseResponseConvenience.eu_options","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience.eu_options","text":"eu_options(n::Integer, bins = nothing; keywords...)\n\nFunction to return a modified tuple of plotting keyword arguments for the EpitopeUncertainty data series. \n\nn must be equal to the number of levels (or larger) of the EpitopeUncertainty object that is plotted. If not bins = nothing the passed bins are marked in the plot with dashed lines (the color can be changed with the keyword bin_color). The bins must specify the indices of the gird intervals, e.g. [[1,2,3],[4,5], [9,10,11]]. The function select_indices can be used to obtain grid indices from grid domain ranges.\n\nMost Plots.jl keywords are available. In addition, the following keyword arguments are available:\n\ncolors = colormap(\"RdBu\",n)[end:-1:1]: Array of colors (that Plots.jl accepts for the color keyword) corresponding to the different uncertainty levels. If the array contains less colors than uncertainty levels, the last color is repeated for the remaining levels.\nopacities = [1]: Array of opacities (number between 0 and 1) that correspond to the different uncertainty levels. Again, the last opacity is repeated if there are more uncertainty levels than opacities.\nreverse = false: If true the plotting order of the uncertainty levels is reversed. Since the uncertainty ranges are plotted on top of each other, this can become necessary when the EpitopeUncertainty constructor for samples is used, where larger levels correspond to larger uncertainty (as opposed to the bin-wise shifting constructor). \nvolume_normalization = :log: Normalizes the grid weights for plotting. If :none the weights are not normalized, if :linear the weights are divided by their corresponding interval length and if :log the weights are divided by the interval length as it appears in a logarithmic plot. See Background: log-volume normalization for further information.\nhide_labels = true: If true the labels are omitted. Can become necessary when a large number of uncertainty levels is used.\nbins = nothing: Specifies the positions for the bin-markers (dashed lines). The bins must specify the interval indices, e.g. [[1,2,3], [5,6]]. Ideally, the bins used for the EpitopeUncertainty construction should be used. If bins = nothing, bin markers are omitted.\nbin_color = :gray: Color of the bin markers.\n\n\n\n\n\n","category":"function"},{"location":"API_Convenience/","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience","text":"du_options","category":"page"},{"location":"API_Convenience/#AntibodyMethodsDoseResponseConvenience.du_options","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience.du_options","text":"du_options(n::Integer; keywords...)\n\nFunction to return a modified tuple of plotting keyword arguments for the DoseResponseUncertainty data series. \n\nn must be equal to the number of levels (or larger) of the DoseResponseUncertainty object that is plotted. \n\nMost Plots.jl keywords are available. In addition, the following keyword arguments are available:\n\ncolors = colormap(\"RdBu\",n)[end:-1:1]: Array of colors (that Plots.jl accepts for the color keyword) corresponding to the different uncertainty levels. If the array contains less colors than uncertainty levels, the last color is repeated for the remaining levels.\nopacities = [1]: Array of opacities (number between 0 and 1) that correspond to the different uncertainty levels. Again, the last opacity is repeated if there are more uncertainty levels than opacities.\nreverse = false: If true the plotting order of the uncertainty levels is reversed. Since the uncertainty ranges are plotted on top of each other, this can become necessary when the EpitopeUncertainty constructor for samples is used, where larger levels correspond to larger uncertainty (as opposed to the bin-wise shifting constructor). \nhide_labels = true: If true the labels are omitted. Can become necessary when a large number of uncertainty levels is used.\nfilter_zeros = [true,false]: Select to omit data points from the plot when the x-value is zero (if true for first element of filter_zeros) or the y-value is zero (if true for second element of filter_zeros). See Measurement data - Plotting) for further information.\n\n\n\n\n\n","category":"function"},{"location":"API_Convenience/#Plotting-functions","page":"AntibodyMethodsDoseResponseConvenience","title":"Plotting functions","text":"","category":"section"},{"location":"API_Convenience/","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience","text":"bin_analysis_plot","category":"page"},{"location":"API_Convenience/#AntibodyMethodsDoseResponseConvenience.bin_analysis_plot","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience.bin_analysis_plot","text":"bin_analysis_plot(results::Union{AdaptiveResult,Nothing},\n\tdata = nothing,\n\treplicates = nothing; \n\tkeywords...\n)\n\nCreate and return basic plots (dr_plot, density_plot) for the DoseResponseResult and the K_τ-density gird. \n\nIf results is an AdaptiveResult, both the fitted gird is plotted into the density plot and the corresponding curve is plotted into the dose-response plot.\n\nIf data is a FittingData object the data points are plotted into the dose-response plot. Similarly, if replicates is an array of FittingData objects, the data points are plotted as replicates in the dose-response plot.\n\nKeywords\n\ndr_plot =dr_base_plot(): The base plot onto which the AdaptiveResult.result and the FittingData objects (data and replicates) are plotted. It can be any Plots.jl plot (e.g. another dose-response plot). \ndensity_plot =density_base_plot(): The base plot onto which the AdaptiveResult.grid is plotted. It can be any Plots.jl plot (e.g. another K_τ density plot).\nfit_arguments =fit_options(): Keyword argument tuple for the AdaptiveResult.result data-series.\ndata_arguments =data_options(): Keyword argument tuple for the FittingData data-series.\nreplicate_arguments =replicate_options(): Keyword argument tuple for the replicate data-series.\ndensity_arguments =density_options(): Keyword argument tuple for the AdaptiveResult.grid data-series.\nannotation_arguments = NamedTuple(): Keyword argument tuple for bin-annotations in the density plot. See below for further information.\n\nAnnotation bins\n\nAnnotation bins allow to annotate the density plot with the number of epitopes (in units of the density values) in the respective bin. The following keywords can be used for the annotation_arguments:\n\nannotation_bins = []: The bins as grid domain ranges, e.g. [[1e-10,1e-9], [1e-9,1e-8], [1e-5,1e-2]].\nannotation_size = 10: Size of the annotation font.\nannotation_offset = 0.05: Relative vertical offset from the top of the plot for the annotation labels. If a single number is provided, every other annotation is offsetted.  If a length-matched vector of numbers is provided, each annotation is individually offsetted accordingly.\nannotation_color = :black: Color of the annotations.\nhover_points = false: If true, adds scatter-points with tool-tips for the Plotly/PlotlyJs backend.\n\n\n\n\n\n","category":"function"},{"location":"API_Convenience/","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience","text":"peak_analysis_plot","category":"page"},{"location":"API_Convenience/#AntibodyMethodsDoseResponseConvenience.peak_analysis_plot","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience.peak_analysis_plot","text":"peak_analysis_plot(results::AdaptiveResult,data = nothing; keywords...)\n\nCreate and return plots to analyze the effect of peaks in the K_τ density on the corresponding dose-response curve.\n\nReturns (individual_dr_plot, cumulative_dr_plot, density_plot), where\n\ndensity_plot contains a plot of the K_τ-density with different colors for the different peaks (specified by the bins).\nindividual_dr_plot contains the individual dose-response curves (color matched) that originate from the different peaks.\ncumulative_dr_plot contains the cumulative dose-response curves, i.e. dose-responses include the response increases caused by peaks with smaller K_τ. Again the curves are color matched with the peaks.\n\nIf data is a FittingData object the data points are plotted in the cumulative_dr_plot.\n\nKeywords\n\nindividual_dr_plot =dr_base_plot(): The base plot onto which the individual dose-response curves are plotted. It can be any Plots.jl plot (e.g. another dose-response plot). \ncumulative_dr_plot =dr_base_plot(): The base plot onto which the cumulative dose-response curves are plotted. It can be any Plots.jl plot (e.g. another dose-response plot). \ndensity_plot =density_base_plot(): The base plot onto which the K_τ-peaks are plotted. It can be any Plots.jl plot (e.g. another K_τ-density plot). \nfit_arguments =fit_options(): Keyword argument tuple for the AdaptiveResult.result data-series. Both color and label get overwritten by the colors keyword and the peak number (automatically determined).\ndensity_arguments =density_options(): Keyword argument tuple for the AdaptiveResult.grid data-series. Both color and label get overwritten by the colors keyword and the peak number (automatically determined).\nbins =peak_detection(results.grid, fill = false)[2]: The bins that define the K_τ-peaks as grid domain ranges, e.g. [[1e-10,1e-9], [1e-9,1e-8], [1e-5,1e-2]].\ncolors = collect(1:length(bins)): The colors for the different bins.\njoin_bins = true: If true, extends the bins if needed, s.t. there remains no gap between the bins.\n\n\n\n\n\n","category":"function"},{"location":"API_Convenience/","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience","text":"uncertainty_plot","category":"page"},{"location":"API_Convenience/#AntibodyMethodsDoseResponseConvenience.uncertainty_plot","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience.uncertainty_plot","text":"uncertainty_plot(e_uncertainty::EpitopeUncertainty,\n\td_uncertainty::DoseResponseUncertainty,\n\tgrid::OneDimGrid; \n\tkeywords...\n)\n\nCreate and return uncertainty visualizations (dr_uncertainty_plot, density_uncertainty_plot).\n\nThe estimated bounds of the DoseResponseUncertainty and EpitopeUncertainty are plotted as color-matched ribbons.\n\nKeywords\n\ndr_plot =dr_base_plot(): The base plot onto which the AdaptiveResult.result and uncertainty ribbons are plotted. It can be any Plots.jl plot (e.g. another dose-response plot). \ndensity_plot =density_base_plot(): The base plot onto which the AdaptiveResult.grid and uncertainty ribbons are plotted. It can be any Plots.jl plot (e.g. another K_τ density plot). \neu_arguments =eu_options(length(e_uncertainty.levels)): Keyword argument tuple for the EpitopeUncertainty data series. See EpitopeUncertainty - plotting for further information.\ndu_arguments =du_options(length(d_uncertainty.levels)): Keyword argument tuple for the DoseResponseUncertainty data series. See DoseResponseUncertainty - plotting for further information.\n\n\n\n\n\n","category":"function"},{"location":"DensityPlots/#Density-plots-for-OneDimGrid","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"","category":"section"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"Consider the following density:","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"using AntibodyMethodsDoseResponseConvenience\nusing Distributions\n\np(x) = pdf(Normal(1e-5,3e-6),x)\nplot(p, xaxis = :log, xlims = [1e-10,1e-2], fill = 0, label = \"density\")","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"In the previous tutorials it was explained how this density can be approximated with a OneDimGrid and how the OneDimGrid can be plotted:","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"using AdaptiveDensityApproximationRecipes\ngrid = create_grid(LogRange(1e-10,1e-2,50))\napproximate_density!(grid, p, volume_normalization = true)\nplot(grid, xaxis = :log)","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"While the grid-plot can be helpful, it can also be distracting for an assessment of the density approximation. ","category":"page"},{"location":"DensityPlots/#The-DensityPlot-recipe","page":"Density plots for OneDimGrid","title":"The DensityPlot recipe","text":"","category":"section"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"The AntibodyMethodsDoseResponseRecipes.jl package offers a plotting recipe to plot the density that a OneDimGrid approximates (this package is automatically imported by AntibodyMethodsDoseResponseConvenience.jl):","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"plot(DensityPlot(grid), xaxis = :log, fill = 0, volume_normalization = :linear, label = \":linear\")","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"Observe that the y-axis now has the same scale as in the density plot.","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"info: volume_normalization\nThe OneDimGrid weights correspond to the number of epitopes lambda_j with K_tau in a given interval I_j, not to the density value g_j = fraclambda_jtextlength(I_j). Thus it is necessary to divide the weights by the interval lengths (volume_normalization = :linear) to obtain the true density shape. However, using the visual volumes of the logarithmic scale (volume_normalization = :log) represents the contribution of peaks to the dose-response curve more accurately (see Background: log-volume normalization). Hence, it is the default normalization despite not being the \"true\" density plot.","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"plot(DensityPlot(grid), xaxis = :log, volume_normalization = :none, \n\tfill = 0, fillapha = 0.5, label = \":none = grid plot\", legend = :topleft)\n\nplot!(DensityPlot(grid), volume_normalization = :log, fill = 0, fillalpha = 0.5, label = \":log\")","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"With DensityAnnotations it is possible to display the total number of epitopes within selected annotation bins, on top of an already existing density plot:","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"plot(DensityPlot(grid), label = \"grid\")\nplot!(DensityAnnotations(grid), xaxis = :log, \n\tvolume_normalization = :log,\n\tannotation_bins = [[1e-10,1e-6], [1e-6,1e-4],[1e-4,1e-2]],\n\tannotation_size = 10,\n\tannotation_offset = [0.2,0.1,0.2],\n\thover_points = false,\n\tannotation_color = :black\n\t)","category":"page"},{"location":"DensityPlots/#Keywords-and-default-arguments","page":"Density plots for OneDimGrid","title":"Keywords and default arguments","text":"","category":"section"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"volume_normalization = :log: This keyword is needed to estimate the height of the annotation markers. Hence it should match the choice for the density plot.\nannotation_bins = []: The selected bins as vector of vectors. The bins are selected based on the K_tau value, not based on the grid interval index. \nannotation_size = 10: Font size for the annotation labels (that show the number of epitopes within the bin).\nannotation_offset = 0.05: Offset of the annotation labels from the top of the plot (as fraction of the plot height). When a single value is provided, the offsets alternate between 0 and the provided value. Alternatively, the offsets can be provided independently for each annotation bin, by providing a length-matched array of offsets.\nhover_points = false: Only recommended if the Plotly/PlotlyJs backend is used. If true, scatter points with the annotation label as tooltip are added, as the Plotly/PlotlyJs backend handles annotations differently.\nannotation_color = :black: The color for the annotation labels and bin lines.","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"info: Number of epitopes\nThe \"number of epitopes\" is calculated in the dimension/unit that the response values are provided in. If the response value is the total number of bound antibody-epitope complexes, the calculated \"number of epitopes\" is indeed the number of epitopes. If the responses are measured as quantity that is only proportional to the number of bound complexes, the \"number of epitopes\" is only proportional to the actual number of epitopes, with the same proportionality constant.","category":"page"},{"location":"DensityPlots/#log_volume_normalization","page":"Density plots for OneDimGrid","title":"Background: log-volume normalization","text":"","category":"section"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"warning: log-volume and standard volume\nlog-volume means the visual volume (visual interval length) in a plot with logarithmic scale, not the logarithm of the volume!. It corresponds to volume_normalization = :log. Standard volume is the true volume (interval length), corresponding to volume_normalization = :linear.","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"To illustrate the benefit of the log-volume normalization for the analysis of dose-response data, we may consider 2 peaks:","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"p_A(x) =  pdf(Normal(1e-6, 3e-7),x)\np_B(x) = pdf(Normal(1e-5,3e-6),x)\np(x) = p_A(x) + p_B(x)\n\nplot(p, xaxis = :log, xlims = [1e-10,1e-2], fill = 0, label = \"density\")","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"As before, the density is approximated with a OneDimGrid:","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"grid = create_grid(LogRange(1e-10,1e-2,100))\napproximate_density!(grid, p, volume_normalization = true)","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"Next, we compare the preferred (default) log-volume normalization with the standard volume normalization (which is true to the actual density). To identify the individual effect of the peaks, we approximate p_A(x) and p_B(x) individually:","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"\ngrid_A = create_grid(LogRange(1e-10,1e-2,100))\napproximate_density!(grid_A, p_A, volume_normalization = true)\n\ngrid_B = create_grid(LogRange(1e-10,1e-2,100))\napproximate_density!(grid_B, p_B, volume_normalization = true)\n\nlv_plot = plot(DensityPlot(grid_A), xaxis = :log, fill = 0, title = \"log-volume\", label = \"peak A\")\nplot!(DensityPlot(grid_B), fill = 0, label = \"peak B\")\n\n\nv_plot = plot(DensityPlot(grid_A), xaxis = :log, volume_normalization = :linear, fill = 0, title = \"volume\", label = \"peak A\")\nplot!(DensityPlot(grid_B), volume_normalization = :linear, fill = 0, label = \"peak B\")\n\nplot(lv_plot, v_plot, layout = (1,2), size = (800,300))","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"With the log-volume normalization both peaks have the same size, suggesting that each peak has the same effect strength w.r.t. to the dose-response curve, albeit at different locations. With the standard volume normalization, however, peak A is significantly larger than peak B, indicating that peak B affects the dose-response curve only marginally. ","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"Since we have approximated grids for each peak individually, as well as for the whole density, it can easily be checked how strong the effect of each peak is, by simulating the corresponding dose-response curves:","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"concentrations = LogRange(1e-10,1e-2, 100)\n\ndr_A = DoseResponseResult(grid_A, concentrations)\ndr_B = DoseResponseResult(grid_B, concentrations)\ndr_total = DoseResponseResult(grid, concentrations)\n\nplot(dr_A, label = \"peak A\", xaxis = :log, legend = :topleft, linewidth = 3)\nplot!(dr_B, label = \"peak B\", linewidth = 3)\nplot!(dr_total, label = \"both peaks\", linewidth = 3)","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"As the log-volume normalized plot suggested, both peaks have the same effect strength w.r.t. to the dose-response curve. The only difference is the location of the effect.","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"remark: Visualization\nWhile the standard volume normalization shows the true density, the log-volume normalization is more useful for the analysis of dose-response curves.","category":"page"},{"location":"Fitting/#fitting","page":"Fitting","title":"Fitting","text":"","category":"section"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"The model generators return a ModelFunctions object. The model field of a ModelFunctions object is a pure Julia function, allowing to implement the model fitting from scratch.","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"using AntibodyMethodsDoseResponseConvenience\nmodel, params = accumulation_model(create_grid([1,2,3]))\ntypeof(model.model) <: Function","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"Yet, since the model generators create a ModelFunctions object, it is convenient to construct the fitting objective with FittingObjectiveFunctions.jl. Then, only the minimization/maximization of the objective function remains to be implemented. Because these steps are always the same, the adaptive_dose_response_fit function summarizes the creation of the model function and the objective function, requiring only the implementation of a function minimizer.","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"tip: Reminder: Convenience workflow\nIf there is no reason to avoid the dependencies of AntibodyMethodsDoseResponseConvenience.jl, the workflow as described in the quick start guide should be used. FittingCondition and fit_condition expose the same options that are described here.","category":"page"},{"location":"Fitting/#The-setting","page":"Fitting","title":"The setting","text":"","category":"section"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"We consider the following measurement data (concentrations, responses, errors):","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"adaptive_result, data, replicates =  load_results(\"examples/default_concentrations\") # hide\nconcentrations = data.independent # hide\nresponses = data.dependent # hide\nerrors = data.errors # hide\nscatter(concentrations,responses, yerror = errors, xaxis = :log, legend = :none)","category":"page"},{"location":"Fitting/#Simple-model-fitting","page":"Fitting","title":"Simple model fitting","text":"","category":"section"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"The data needs to be summarized in a FittingData object, as described in Models:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"data = FittingData(concentrations, responses, errors)","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"Next, a OneDimGrid needs to be created, ideally covering the concentration range:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"grid = create_grid(LogRange(1e-10,1e-2,40))","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"Finally, a function minimizer needs to be implemented. For this, we use Optim.jl, here:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"function minimizer(f,∇f,init)\n\tlower = zeros(length(init))\n\tupper = [Inf for i in 1:length(init)]\n\treturn optimize(f,lower,upper, init, Fminbox(NelderMead()),\n\t\t\tOptim.Options(g_tol = 1e-12, iterations =2000)).minimizer\nend","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"The implemented minimizer must take the objective function f, its gradient function ∇f, if applicable, and an initial parameter array init as arguments and return the minimizing parameters. Furthermore, since K_tau geq 0, the optimization domain should be limited.","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"Now, a model can be fitted to the data with adaptive_dose_response_fit:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"result = adaptive_dose_response_fit(grid,data,\n\t\tminimizer, \n\t\toptions = AdaptiveOptions(model = accumulation_model)\n\t)","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"result =  deserialize(\"examples/direct_fit/results.jld\") # hide","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"adaptive_dose_response_fit returns an AdaptiveResult object, that has the following fields:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"optimizer: The estimated parameters (result of model fitting).\nobjective_value: The objective function value for the estimated parameters.\ngrid: A grid containing the estimated parameters as grid weights.\nresult: The DoseResponseResult object corresponding to the grid (and the offset parameter).\ntime: The elapsed time for the model fit (in seconds).","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"scatter(data, xaxis = :log, legend = :topleft, label = \"data\")\nplot!(result.result, label = \"fit result\")","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"plot(DensityPlot(result.grid), xaxis = :log, color = 2, fill = 0, \n\tfillalpha = 0.5, label = \"fit result\")","category":"page"},{"location":"Fitting/#adaptive_model_fitting","page":"Fitting","title":"Adaptive model fitting","text":"","category":"section"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"The model fit above can be improved in two areas. First, a regularization could be used. Second, the adaptive density approximation from AdaptiveDensityApproximation.jl could be used to reduce the number of parameters. Here, we recreate the default optimization from the AntibodyMethodsDoseResponseConvenience.jl package as described in the quick start guide to illustrate some of the available options.","category":"page"},{"location":"Fitting/#Setting-up-the-objective-function-properties","page":"Fitting","title":"Setting up the objective function properties","text":"","category":"section"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"For the regularization, a log-posterior objective can be used, where a smoothing prior defines the regularization. ","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"Log-posterior objectives differ from posterior objectives only by taking the logarithm of all functions. Mathematically, there is no difference, but for the computation of tiny probabilities, taking the logarithm upfront is numerically beneficial. Accordingly, the prior also needs to be defined as log-prior, i.e. as the logarithm of the prior.","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"While FittingObjectiveFunctions.jl expects standard functions as prior/log-prior, adaptive_dose_response_fit requires a prior-generating function (Here, the 500 is used to reproduce the scale = 500 from the quick start guide):","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"function log_prior_generator(centers, volumes, offset)\n\tℓV = log.(centers .+ volumes/2) .- log.(centers .- volumes/2)\n\tif isnothing(offset)\n\t\treturn λ ->  -500*(sum((λ[i]/ℓV[i]-λ[i+1]/ℓV[i+1])^2 for i in 1:length(λ)-1))/length(λ)^2\n\telse\n\t\treturn λ -> -500*(sum((λ[i]/ℓV[i]-λ[i+1]/ℓV[i+1])^2 for i in 1:length(λ)-2) + λ[end]^2)/length(λ)^2\n\tend\nend","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"The prior generator above will create a new log-prior function for each step of the adaptive fitting. The returned log-prior function reads:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"textlog-prior(lambda) = -frac500textlength(lambda)^2 left(lambda_textoffset + sum_i=1^n-1 left( fraclambda_iell V_i - fraclambda_i+1ell V_i+1 right)^2 right)","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"Since the default density-visualization of grids rescales the weights by using the visual interval lengths in a logarithmic scale ℓV (see Background: log-volume normalization), the smoothing should be applied to the rescaled parameters λ. Hence, the λ[i] are divided by ℓV[i].","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"Next, observe that the log-prior is just the logarithm of a normal distribution (up to a missing normalization) for the difference of the rescaled parameters. Essentially, the prior assumes that there is no difference between neighboring parameters where the scale frac500textlength(lambda)^2 expresses the strength/importance of this assumption. This is the aforementioned smoothing.","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"info: Why prior-generator functions?\nUsing log-prior generating functions seems unnecessarily complicated, at first. However, during the adaptive fit, the underlying grid approximation changes, leading to different (visual) interval lengths. Defining a fixed function for the prior could not take the change of interval lengths into account, i.e. the parameters could not be rescaled properly. Hence, the prior needs to be recalculated after every change of the grid, which requires a function that generates the prior from the grid properties.","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"Without additional information about the measurement errors, a normal distribution is a sensible choice for the uncertainty distribution. Since the goal is a log-posterior objective, the logarithm of a normal distribution (y,m,Δy)-> -(y-m)^2/Δy^2 must be used:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"data = FittingData(concentrations,responses, errors, distributions = (y,m,Δy)-> -(y-m)^2/Δy^2)","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"Here, y denotes the data point value, m denotes the model value calculated from the parameters and Δy denotes the measurement error. Uncertainty distributions must take the arguments in this order (y,m,Δy) and must return the distribution / log-distribution value.","category":"page"},{"location":"Fitting/#Setting-up-the-minimizers","page":"Fitting","title":"Setting up the minimizers","text":"","category":"section"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"As before, a minimizer needs to be defined:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"function minimizer(f,∇f,init)\n\tlower = zeros(length(init))\n\tupper = [Inf for i in 1:length(init)]\n\treturn optimize(f,lower,upper, init, Fminbox(NelderMead()),\n\t\tOptim.Options(g_tol = 1e-12, iterations =2000)).minimizer\nend","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"info: Minimization and log-posterior?\nLikelihood and posterior objectives usually need to be maximized. However, Optim.jl only provides minimizers, as do some other optimization packages, expecting from the user to flip the sign of the function for a maximization. adaptive_dose_response_fit flips the sign of the posterior and log-posterior objectives automatically.","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"But, to recreate the default fitting from the quick start guide, a second minimizer is needed (using the LBFGS algorithm):","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"function post_minimizer(f,∇f,init)\n\tlower = zeros(length(init))\n\tupper = [Inf for i in 1:length(init)]\n\treturn optimize(f,lower,upper, init, Fminbox(LBFGS()),\n\t\tOptim.Options(g_tol = 1e-12, iterations =2000)).minimizer\nend","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"The second minimizer will be applied after the adaptive optimization to fine-tune the results with a gradient based minimizer. ","category":"page"},{"location":"Fitting/#Setting-up-the-options","page":"Fitting","title":"Setting up the options","text":"","category":"section"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"Before fitting the data, the fitting options (AdaptiveOptions) and the initial grid need to be defined. Among others, the objective and the prior-generator defined above need to be selected (the additional options in the example are needed to obtain the defaults from the quick start guide):","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"adaptive_options = AdaptiveOptions(objective = :log_posterior, \n\titerations = 30, \n\toffset = eps(), \n\tprior_generator = log_prior_generator\n)","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"The idea of the adaptive approximation is to start with a coarse grid, containing only 2 intervals (3 interval edges):","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"grid = create_grid(LogRange(1e-10,1e-2,3)) ","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"info: Adaptive fitting\nWith only 2 parameters, common optimizers find a good minimum even for suboptimal initial parameters. Then, the grid can be refined in regions of interest. Next, the previous result can be used as good initial point for the optimization. This process can be repeated several times, increasing the number intervals for regions of interest while not wasting computation time with small intervals for uninteresting regions.","category":"page"},{"location":"Fitting/#Fitting","page":"Fitting","title":"Fitting","text":"","category":"section"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"Now, the data can be fitted with adaptive_dose_response_fit:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"adaptive_result = adaptive_dose_response_fit(grid,data,minimizer, options = fitting_options)","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"To fine-tune the result with the gradient-based minimizer from above, adaptive_dose_response_fit needs to be called again with different options (i.e. no iterations to obtain a single fit and using the offset from the previous result):","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"post_options = AdaptiveOptions(objective = :log_posterior, \n\toffset = result.optimizer[end], \n\tprior_generator = log_prior_generator\n)\n\nadaptive_result = adaptive_dose_response_fit(adaptive_result.grid,data,\n\t\tpost_minimizer, \n\t\toptions = post_options\n\t)","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"adaptive_result # hide","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"As before, the fitted dose-response curve describes the data well:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"scatter(data, xaxis = :log, legend = :topleft, label = \"data\")\nplot!(adaptive_result.result, label = \"fit result\", color = 3)","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"But comparing the estimated densities from the simple model fit and the adaptive model reveals the difference:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"plot(DensityPlot(result.grid), xaxis = :log, color = 2, \n\tfill = 0, fillalpha = 0.5, legend = :topleft, label = \"simple fit\")\n\nplot!(DensityPlot(adaptive_result.grid), color = 3, \n\tfill = 0, fillalpha = 0.5, label = \"adaptive fit\")","category":"page"},{"location":"Fitting/#The-same-options-in-the-convenience-workflow","page":"Fitting","title":"The same options in the convenience workflow","text":"","category":"section"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"As mentioned above, the convenience workflow exposes the same options as adaptive_dose_response_fit. Although the adaptive model fitting section uses options that are already the defaults of the convenience workflow, this section creates these options explicitly to illustrate how to modify the options and to illustrate the convenience gain.","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"First, the log-prior-generator (with the scale 500) can be obtained with scaled_log_volume_prior:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"using AntibodyMethodsDoseResponseConvenience #hide\nadaptive_result, data, replicates =  load_results(\"examples/default_concentrations\") # hide\nconcentrations = data.independent # hide\nresponses = data.dependent # hide\nerrors = data.errors # hide\nlog_prior_generator = scaled_log_volume_prior(500)","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"The FittingData object is created as before.","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"data = FittingData(concentrations,responses, errors, distributions = (y,m,Δy)-> -(y-m)^2/Δy^2)","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"The Optim.jl minimizers can be obtained with less boilerplate code, using minimizer_generator:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"minimizer = minimizer_generator(NelderMead())\npost_minimizer = minimizer_generator(LBFGS())","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"In general, the grid is created automatically, based on the concentration range of the dose-response data. However, if one concentration is 0, the automatic grid should not be used.","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"grid = create_grid(LogRange(1e-10,1e-2,3)) ","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"info: automatic grids and the zero concentration\nThe automatic grids are created with the LogRange function and are intended for logarithmic plots. A zero-concentration would lead to a DomainError, as LogRange demands positive numbers. To avoid an error, the automatic grid generator then substitutes eps() for 0 (only for the auto-generated grid) and raise a warning. However, too large grid domains lead to poor fit results. Hence, it is recommended to create the grid manually in those cases.","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"The same options as before are used:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"adaptive_options = AdaptiveOptions(objective = :log_posterior, iterations = 30, \n\t\t\toffset = eps(), prior_generator = log_prior_generator)\n\npost_options = AdaptiveOptions(objective = :log_posterior, offset = eps(), \n\t\t\tprior_generator = log_prior_generator)","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"Finally, the objects, functions and options from above need to be summarized in a FittingCondition object:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"condition = FittingCondition(data,\n\tgrid = grid,\n\toptions_1 = adaptive_options,\n\toptions_2 = post_options,\n\tminimizer_1 = minimizer,\n\tminimizer_2 = post_minimizer\n\t)","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"Fitting the condition is done by calling fit_condition:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"result = fit_condition(condition)\nplot(DensityPlot(result.grid), xaxis = :log, fill = 0, fillalpha = 0.5)","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"plot(DensityPlot(adaptive_result.grid), xaxis = :log, fill = 0, fillalpha = 0.5) #hide","category":"page"},{"location":"Fitting/#Multi-threaded-fitting","page":"Fitting","title":"Multi-threaded fitting","text":"","category":"section"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"The fitting of a single condition cannot be parallelized. However, fitting more than one condition can be done in parallel. Consider an array of FittingCondition objects:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"conditions = [condition_1,condition_2,condition_3]","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"The conditions can be fitted in parallel with fit_conditions (observe the additional s):","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"fit_conditions(conditions)","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"info: Multi-threading\nThe number of threads cannot be changed after Julia is launched. The number of threads needs to be set in before, e.g. with julia -t 8 to run Julia with 8 threads. The number of threads can be checked with Threads.nthreads().","category":"page"},{"location":"Fitting/#Changing-the-initial-values","page":"Fitting","title":"Changing the initial values","text":"","category":"section"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"In each case discussed here, no initial parameter values were set for the model fitting. This is, because the wights of the gird are used as initial values. By default, create_grid sets all weights to 1:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"grid = create_grid(LogRange(1e-10,1e-2,3)) \nexport_weights(grid)","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"Changing the weights of the gird before running the fitting-process allows to specify the initial values for the model fitting. E.g. for the manual definition of adaptive fitting:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"import_weights!(grid,[eps(),1])\nadaptive_result = adaptive_dose_response_fit(grid,data,minimizer, options = fitting_options)","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"Or for the convenience workflow, e.g. after the FittingCondition has already been defined:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"import_weights!(condition.grid,[eps(),1])\nresult = fit_condition(condition)","category":"page"},{"location":"Uncertainty/#Uncertainty-estimation","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"","category":"section"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"The posterior and log-posterior objectives (as used in the Fitting tutorial) from FittingObjectiveFunctions.jl belong to a Bayesian data analysis approach. In this analysis regime, it is important to consider not only the best fit but also less probable parameters to estimate the uncertainty of the fit result.","category":"page"},{"location":"Uncertainty/#[EpitopeUncertainty](@ref)-construction","page":"Uncertainty estimation","title":"EpitopeUncertainty - construction","text":"","category":"section"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"The EpitopeUncertainty type collects and stores the uncertainty of a K_tau-density. To illustrate how to obtain an uncertainty estimation, we consider the adaptive fit results from the Fitting tutorial:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"using AntibodyMethodsDoseResponseConvenience# hide\nusing Measures # hide\nadaptive_result, data, replicates =  load_results(\"examples/default_concentrations\") # hide\ndr_plot = scatter(data, xaxis = :log, label = \"data\", legend = :topleft) # hide\nplot!(adaptive_result.result, label = \"adaptive_result.result\") # hide\ndensity_plot = plot(DensityPlot(adaptive_result.grid), xaxis = :log, color = 2, fill = 0, fillalpha = 0.5, label = \"adaptive_result.grid\") # hide\nplot(dr_plot, density_plot, layout = (1,2), size = (800,300), margins = 4mm, legend = :topleft) # hide","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"A question of interest could be the uncertainty of the individual peaks. For this, the index-bins belonging to the different peaks need to be identified. Using peak_detection and setting the threshold to 0.01 results in:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"bins, ranges = peak_detection(adaptive_result.grid, 0.01)","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"peak_detection returns the identified peaks both as bins (indices of intervals) and the grid-domain ranges. By default, the regions between peaks are also included (fill = true) and the peaks are determined with volume_normalization = :log (see Background: log-volume normalization).","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"info: Info\nFor plotting purposes (bin_analysis_plot, peak_analysis_plot), the bins need to specify the grid-domain ranges, e.g. [[1e-10,1e-8],[1e-5,1e-3]]. For the uncertainty estimation and uncertainty plotting (uncertainty_plot), the bins need to specify the grid intervals that are varied, e.g. [[1,2,3],[5,8]].","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"tip: Tip\nDefining grid-domain ranges is often easier than figuring out which gird intervals belong to those ranges. The select_indices function allows to pick the interval indices belonging to a gird-domain range.","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"Having defined the interval groups of interest, the uncertainty can be estimated by fixing all parameters to the fit result, shifting uniformly only the parameters belonging to the current group of interest. This process is then repeated for all interval groups. Evaluating the objective function for each shift allows to estimate the uncertainty of the interval group.","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"(Image: UncertaintyShift)","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"This uncertainty estimation from bin-wise shifting can be obtained with the following EpitopeUncertainty constructor:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"adaptive_options = AdaptiveOptions(objective = :log_posterior, \n\t\tprior_generator = scaled_log_volume_prior(500),\n\t\toffset = adaptive_result.optimizer[end]\n\t\t)\n\neu = EpitopeUncertainty(data,adaptive_result.grid, bins, \n\t\tlevels = [1e-10,1e-5,0.1,0.25,0.5,0.75,0.9,1], \n\t\toptions = adaptive_options\n\t\t)","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"eu = deserialize(\"examples/uncertainty/eu.jld\") # hide","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"The bin-wise shifting constructor EpitopeUncertainty generates the objective function automatically, using the same methods as adaptive_dose_response_fit, hence the need for an AdaptiveOptions object. In the example above, the options were chosen to match those from the Fitting tutorial section.","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"Notice the offset = adaptive_result.optimizer[end] line. Since the default fitting algorithm that was recreated in the Fitting tutorial section uses the offset parameter, the estimated offset must be added to the uncertainty estimation, as it shifts up the resulting dose-response curve globally. Recall, that the offset parameter is the last element of the returned optimizer field of an AdaptiveResult object.","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"Finally, the uncertainty levels are specified as fractions of the best objective value.","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"info: Uncertainty estimation from samples\nThere is also an EpitopeUncertainty constructor that uses samples, drawn from a posterior or log-posterior objective. However, the sample constructor does not support the selection of bins. Quantiles corresponding to the chosen levels are calculated for each parameter individually. Furthermore, no sample algorithm is provided by the AntibodyMethods packages.","category":"page"},{"location":"Uncertainty/#EpitopeUncertainty-plotting","page":"Uncertainty estimation","title":"EpitopeUncertainty - plotting","text":"","category":"section"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"AntibodyMethodsDoseResponseRecipes.jlprovides a plotting recipe for EpitopeUncertainty objects. To define the color-gradient for the uncertainty visualization, Colors.jl is used here. Both packages (and also Plots.jl) are automatically exported by AntibodyMethodsDoseResponseConvenience.jl. The EpitopeUncertainty object eu can be plotted by passing the grid adaptive_result.grid and the EpitopeUncertainty object eu to the plot function:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"uncertainty_colors =colormap(\"RdBu\", 8)[end:-1:1]\nplot(adaptive_result.grid, eu, xaxis = :log, legend = :topleft,\n\tcolors = uncertainty_colors, \n\thide_labels = false,\n\tbins = bins\n\t)","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"The colormap function from Colors.jl creates an array of colors (here 8 colors, which matches the number of uncertainty levels). The [end:-1:1] is used to reverse the colors (now from blue to red). Thus, the lower levels (less certain) are blue while the best result is red.","category":"page"},{"location":"Uncertainty/#Keywords-with-default-arguments","page":"Uncertainty estimation","title":"Keywords with default arguments","text":"","category":"section"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"volume_normalization = :log: The volume-normalization as discussed in Background: log-volume normalization.\ncolors = [:gray]: An array of colors (that Plots.jl accepts for the color keyword) that correspond to the different uncertainty levels. If the array contains less colors than uncertainty levels, the last color is repeated for the remaining levels.\nopacities = [1]: Array of opacities (number between 0 and 1) that correspond to the different uncertainty levels. Again, the last opacity is repeated if there are more uncertainty levels than opacities.\nreverse = false: If true the plotting order of the uncertainty levels is reversed. Since the uncertainty ranges are plotted on top of each other, this can become necessary when the EpitopeUncertainty constructor for samples is used, where larger levels correspond to larger uncertainty (as opposed to the bin-wise shifting constructor). \nhide_labels = true: If true the labels are omitted. Can become necessary when a large number of uncertainty levels is used.\nbins = nothing: Specifies the positions for the bin-markers (dashed lines). The bins should be the same as those used in the EpitopeUncertainty constructor. If nothing, bin markers are omitted.\nbin_color = :gray: Color of the bin markers.","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"warning: Interpretation of the uncertainty\nAs explained above, the uncertainty is estimated by keeping all bins fixed, only shifting one bin at a time. Thus, the bin uncertainties have to be considered individually. It is not admissible to combine the uncertainty of the bins: E.g. to consider shifting the first peak up and shifting the second peak down within the 1e-10 uncertainty region and then to declare this to have the uncertainty 1e-10.It is not admissible to consider partial shifts within a bin: E.g. shifting only the tip of the first peak, but not the other parts of the peak. The uncertainty level is only valid for the uniform shift of all parameters within a bin.","category":"page"},{"location":"Uncertainty/#[DoseResponseUncertainty](@ref)-construction","page":"Uncertainty estimation","title":"DoseResponseUncertainty - construction","text":"","category":"section"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"Given an EpitopeUncertainty object and the corresponding grid, a DoseResponseUncertainty object can be created. In essence, the dose-response uncertainty is obtained by simulating dose-response curves for the different parameters contained in the EpitopeUncertainty object. Hence, the concentrations for which these dose-responses curves are simulated need to be passed explicitly:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"concentrations = LogRange(extrema(data.independent)...,100)\ndu = DoseResponseUncertainty(adaptive_result.grid, eu, concentrations, bins = bins)","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"du = deserialize(\"examples/uncertainty/du.jld\") # hide","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"The same bins that were used to create the EpitopeUncertainty object should also be used for the DoseResponseUncertainty constructor. This is, because the dose-response uncertainty is calculated as point-wise maximum/minimum over the effect of the individual uncertainty-variation of each bin. The following example illustrates the dose-response uncertainties that result from the individual peak uncertainties (dashed lines), both for the same uncertainty level. The green ribbon shows the resulting overall dose-response uncertainty (for the same uncertainty level):","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"concentrations = LogRange(extrema(data.independent)...,100) # hide\n\ngrid_A = deepcopy(adaptive_result.grid) # hide\ngrid_B = deepcopy(adaptive_result.grid) # hide\ncutoff = select_indices(grid_A, lower = 1e-5)[1] # hide\nprintln(cutoff) # hide\n\nweights_A = export_weights(grid_A) # hide\nweights_A[1:cutoff] .= weights_A[1:cutoff] .* 1.2 # hide\nimport_weights!(grid_A, weights_A) # hide\n\nweights_B = export_weights(grid_B) # hide\nweights_B[cutoff:end] .= weights_B[cutoff:end] .* 1.4 # hide\nimport_weights!(grid_B, weights_B) # hide\n\ndr_fit = DoseResponseResult(adaptive_result.grid, concentrations) # hide\ndr_A = DoseResponseResult(grid_A, concentrations) # hide\ndr_B = DoseResponseResult(grid_B, concentrations) # hide\ndr_sum = DoseResponseResult(concentrations, max.(dr_A.responses,dr_B.responses)) # hide\n\nplot(dr_fit, xaxis = :log, color = :red, label = \"best fit\", legend = :topleft, linewidth = 3, xlabel = \"concentration\", ylabel = \"response\") # hide\nplot!(dr_sum, color = :green, label = \"component maxiumum\", linewidth = 0, fill = dr_fit.responses, fillalpha = 0.5) # hide\nplot!(dr_A,  linestyle = :dash, color = :blue, label = \"peak 1 variation\", linewidth = 2.5) # hide\nplot!(dr_B,  linestyle = :dashdotdot, color = \"Blue Violet\", label = \"peak 2 variation\", linewidth = 2.5) # hide","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"Note that the concentrations array covers the same concentration range as the dose-response data points, but contains much more intermediate concentrations:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"println(data.independent)\nprintln(concentrations)","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"tip: Tip\nUsing more intermediate concentrations is recommended to avoid jagged lines.","category":"page"},{"location":"Uncertainty/#DoseResponseUncertainty-plotting","page":"Uncertainty estimation","title":"DoseResponseUncertainty - plotting","text":"","category":"section"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"As before, AntibodyMethodsDoseResponseRecipes.jl provides a plotting recipe for DoseResponseUncertainty objects:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"plot(du, xaxis = :log, legend = :topleft, colors = uncertainty_colors, hide_labels = false)\nscatter!(data, color = \"Dark Orange\", label = \"data\") # compare uncertainty with data","category":"page"},{"location":"Uncertainty/#Keywords-with-default-arguments-2","page":"Uncertainty estimation","title":"Keywords with default arguments","text":"","category":"section"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"filter_zeros = [true, false]: Remove zero-values from the plot (works the same as explained in Measurement data - Plotting).\ncolors = [:gray]: Same as EpitopeUncertainty plotting above.\nopacities = [1]: Same as EpitopeUncertainty plotting above.\nreverse = false: Same as EpitopeUncertainty plotting above.\nhide_labels = true: Same as EpitopeUncertainty plotting above.","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"warning: Interpretation of the uncertainty\nAs explained above, the uncertainty is estimated by keeping all bins fixed, only using the uncertainty estimation of one bin at a time. Then, the dose-response curves are simulated for all individual bin uncertainties. Finally, for each concentration the maximal/minimal response value is collected by considering all individual bin uncertainties.  Thus, comparing the dose-response uncertainty with the uncertainty of an individual peak is not directly possible. It rather shows the worst-case uncertainty if any of the peaks (but only one) would be shifted within a certain uncertainty level.Nevertheless, it is possible to gauge the uncertainty effect of a single peak, by considering only the concentration region of the dose-response curve that matches the K_tau region of the peak.","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"info: Why component wise maxima/minima?\nThe component-wise maxima/minima are just a compromised way to combine the uncertainty corresponding to all the individual peaks into a single plot. Using a different plot for each peak would be less confusing, but less concise. Also, the component-wise maxima/minima do not correspond to the overall uncertainty, i.e. when all peaks are shifted within an uncertainty level at the same time. Example: Total uncertainty shows how to obtain the total dose-response uncertainty.","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"tip: Different plots for different aspects\nCombining to many aspects into a single plot leads to misinterpretation. Choosing different bins allows to obtain different uncertainty estimations, as the examples below show.","category":"page"},{"location":"Uncertainty/#Plotting-with-[uncertainty_plot](@ref)","page":"Uncertainty estimation","title":"Plotting with uncertainty_plot","text":"","category":"section"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"Since the uncertainty estimation involves various subtleties, it is not discussed in the quick start guide. However, AntibodyMethodsDoseResponseConvenience.jl contains a convenience function (uncertainty_plot) to create the uncertainty plots. The available methods to customize the plots are discussed in quick start: plotting options.","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"The plots from above can be recreated with uncertainty_plot:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"du_plot, eu_plot = uncertainty_plot(eu,du,adaptive_result.grid,\n\t\teu_arguments = eu_options(8, bins, hide_labels = false),\n\t\tdu_arguments = du_options(8, hide_labels = false)\n\t\t)","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"Both eu_options and du_options expect the number of uncertainty levels as first argument. eu_options takes the bins as second, optional argument. Then, the respective uncertainty-plot keywords discussed above can be added to eu_options and du_options.","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"plot(eu_plot)","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"plot(du_plot)\nscatter!(data, color = \"Dark Orange\", label = \"data\") # plot data points on top","category":"page"},{"location":"Uncertainty/#Rescale-the-bin-wise-shifts","page":"Uncertainty estimation","title":"Rescale the bin-wise shifts","text":"","category":"section"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"By default (volume_normalization = :none), all weights within the same bin are shifted uniformly. However, the corresponding intervals may have different lengths. And the contribution of an interval is given by the product weight × interval length. Hence, scaling the wight shifts according to their corresponding interval length provides further uncertainty estimation methods from bin-wise weight shifting. For this, the volume_normalization = :linear keyword can be used in the EpitopeUncertainty constructor, leading to","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"eu = deserialize(\"examples/uncertainty_volume/eu.jld\") # hide\ndu = deserialize(\"examples/uncertainty_volume/du.jld\") # hide\n\ndu_plot, eu_plot = uncertainty_plot(eu,du,adaptive_result.grid, eu_arguments = eu_options(8, bins, hide_labels = false), du_arguments = du_options(8, hide_labels = false)) # hide\n\ndu_plot = plot(du_plot) # hide\nscatter!(data, color = \"Dark Orange\", label = \"data\") # hide\n\nplot(eu_plot, du_plot, layout = (1,2), size = (800,300), margins = 5mm) # hide","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"Observe that the shifts become larger for larger K_tau values. Although the intervals appear to have the same lengths, the intervals further right in the plot are larger, because of the logarithmic plot. Hence, the shifts, when scaled by the interval length, become larger. Note that this behavior is universal, i.e. not necessarily depending on the uncertainty itself but on the fact of the unequal size of logarithmically sized intervals.","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"As mentioned in Background: log-volume normalization, it is in fact the visual area of the intervals in the logarithmic plot that corresponds to the dose-response effect of the interval. Thus, scaling the shifts with the visual lengths of the intervals, as they appear in a logarithmic plot, is another approach to investigate the uncertainty with bin-wise weight shifting. This can be achieved by volume_normalization = :log:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"eu = deserialize(\"examples/uncertainty_log_volume/eu.jld\") # hide\ndu = deserialize(\"examples/uncertainty_log_volume/du.jld\") # hide\n\ndu_plot, eu_plot = uncertainty_plot(eu,du,adaptive_result.grid, eu_arguments = eu_options(8, bins, hide_labels = false), du_arguments = du_options(8, hide_labels = false)) # hide\n\ndu_plot = plot(du_plot) # hide\nscatter!(data, color = \"Dark Orange\", label = \"data\") # hide\n\nplot(eu_plot, du_plot, layout = (1,2), size = (800,300), margins = 5mm) # hide","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"Since the intervals have almost the same length in the logarithmic plot, the shifts are almost identical (for the respective bin).","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"info: Info\nIn summary, the different re-scalings of the shifts provide additional methods to investigate the uncertainty. Since bin-wise shifts only approximate the uncertainty roughly (as sampling is computationally expensive), different scalings reveal different aspects of the uncertainty, by testing different configuration of deviations from the best fit. Hence, no scaling is superior to the others, they just answer slightly different questions about the uncertainty.","category":"page"},{"location":"Uncertainty/#of_single_peak","page":"Uncertainty estimation","title":"Example: Uncertainty of a single peak","text":"","category":"section"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"The interpretation of the uncertainty plots can be tricky at times, which is addressed by the warnings above. In the example above, it is not possible to compare the dose-response uncertainty with the uncertainty of a single bin. To do so, the uncertainty estimation needs to be restricted to a single peak:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"temp_bins, temp_ranges = peak_detection(adaptive_result.grid, 0.01)\nbins = [temp_bins[2]]\nprintln(bins) # hide","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"Using [temp_bins[2]] creates a vector of bins, in this case with only a single bin - the second peak from left. Simply using temp_bins[2] will not work; it will create separate bins, each containing only a single element.","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"Now, the uncertainty estimation proceeds as before:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"adaptive_options = AdaptiveOptions(objective = :log_posterior, \n\t\tprior_generator = scaled_log_volume_prior(500),\n\t\toffset = adaptive_result.optimizer[end]\n\t\t)\n\neu = EpitopeUncertainty(data,adaptive_result.grid, bins, \n\t\tlevels = [1e-10,1e-5,0.1,0.25,0.5,0.75,0.9,1], \n\t\toptions = adaptive_options\n\t\t)\n\nconcentrations = LogRange(extrema(data.independent)...,100)\ndu = DoseResponseUncertainty(adaptive_result.grid, eu, concentrations, bins = bins)","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"eu = deserialize(\"examples/uncertainty_single/eu.jld\") # hide\ndu = deserialize(\"examples/uncertainty_single/du.jld\") # hide","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"These uncertainty objects produce the following plots:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"using Measures # hide\n\ndu_plot, eu_plot = uncertainty_plot(eu,du,adaptive_result.grid, eu_arguments = eu_options(8, bins, hide_labels = false), du_arguments = du_options(8, hide_labels = false)) # hide\n\ndu_plot = plot(du_plot) # hide\nscatter!(data, color = \"Dark Orange\", label = \"data\") # hide\n\nplot(eu_plot, du_plot, layout = (1,2), size = (800,300), margins = 5mm) # hide","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"info: Interpretation\nIn this case, the uncertainty of the dose-response curve corresponds exclusively to the uncertainty of the middle peak (other uncertainties have not been estimated).","category":"page"},{"location":"Uncertainty/#in_single_peak","page":"Uncertainty estimation","title":"Example: Uncertainty in a single peak","text":"","category":"section"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"In the example above, the use of [temp_bins[2]] was emphasized. Using temp_bins[2] will create single-element bins (that are contained in the bin temp_bin[2]). Internally, single-element arrays are converted to [[elm] for elm in collection].","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"But it is worthwhile to consider this case. It corresponds to the uncertainty of the individual parameters in temp_bin[2], where one parameter at a time is varied, keeping the rest fixed to the best fit result.","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"temp_bins, temp_ranges = peak_detection(adaptive_result.grid, 0.01)\nbins = temp_bins[2]\nprintln(bins) # hide","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"The uncertainty estimation and plotting work as before:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"using Measures # hide\neu = deserialize(\"examples/uncertainty_split/eu.jld\") # hide\ndu = deserialize(\"examples/uncertainty_split/du.jld\") # hide\n\ndu_plot, eu_plot = uncertainty_plot(eu,du,adaptive_result.grid, eu_arguments = eu_options(8, bins, hide_labels = false), du_arguments = du_options(8, hide_labels = false)) # hide\n\ndu_plot = plot(du_plot) # hide\nscatter!(data, color = \"Dark Orange\", label = \"data\") # hide\n\nplot(eu_plot, du_plot, layout = (1,2), size = (800,300), margins = 5mm) # hide","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"info: Interpretation\nThe same warnings as before apply. The uncertainty of only the individual parameters (in this case) can be deduced from this plot, as is also indicated by the bin markers. It is not valid to combine the uncertainties (e.g. move one parameter up and its neighbor down). Also, the uncertainty of a single parameter cannot be compared directly to the dose-response uncertainty. ","category":"page"},{"location":"Uncertainty/#global_uncertainty","page":"Uncertainty estimation","title":"Example: Global uncertainty","text":"","category":"section"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"The example Uncertainty of a single peak indicates how to estimate the global-shift uncertainty:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"bins = [collect(1:length(adaptive_result.grid))]","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"The uncertainty estimation and plotting work as before:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"using Measures # hide\neu = deserialize(\"examples/uncertainty_global/eu.jld\") # hide\ndu = deserialize(\"examples/uncertainty_global/du.jld\") # hide\n\ndu_plot, eu_plot = uncertainty_plot(eu,du,adaptive_result.grid, eu_arguments = eu_options(8, hide_labels = false), du_arguments = du_options(8, hide_labels = false)) # hide\n\ndu_plot = plot(du_plot) # hide\nscatter!(data, color = \"Dark Orange\", label = \"data\") # hide\n\nplot(eu_plot, du_plot, layout = (1,2), size = (800,300), margins = 5mm) # hide","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"info: Interpretation\nHere, the complete K_tau-density is shifted (globally). Since this is the only \"bin\", the dose-response uncertainty corresponds directly to this uncertainty. Again, it is not admissible to consider individual parameters/peaks/parts moving in different directions. The result is only valid for global/uniform shifts. ","category":"page"},{"location":"Uncertainty/#individual_uncertainty","page":"Uncertainty estimation","title":"Example: Individual uncertainty","text":"","category":"section"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"The example Uncertainty in a single peak indicates how to estimate the uncertainty for all parameters individually:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"bins = collect(1:length(adaptive_result.grid))\nprintln(bins) # hide","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"The uncertainty estimation and plotting work as before:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"using Measures # hide\neu = deserialize(\"examples/uncertainty_total/eu.jld\") # hide\ndu = deserialize(\"examples/uncertainty_total/du.jld\") # hide\n\ndu_plot, eu_plot = uncertainty_plot(eu,du,adaptive_result.grid, eu_arguments = eu_options(8, bins = collect(1:length(adaptive_result.grid)),  hide_labels = false), du_arguments = du_options(8, hide_labels = false)) # hide\n\ndu_plot = plot(du_plot) # hide\nscatter!(data, color = \"Dark Orange\", label = \"data\") # hide\n\nplot(eu_plot, du_plot, layout = (1,2), size = (800,300), margins = 5mm) # hide","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"info: Interpretation\nThe same warnings as before apply. The uncertainty of only the individual parameters (in this case) can be deduced from this plot, as is also indicated by the bin markers. It is not valid to combine the uncertainties (e.g. move one parameter up and its neighbor down). Also, the uncertainty of a single parameter cannot be compared directly to the dose-response uncertainty. ","category":"page"},{"location":"Uncertainty/#total_uncertainty","page":"Uncertainty estimation","title":"Example: Total uncertainty","text":"","category":"section"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"So far, the same bins were used for both the EpitopeUncertainty and the DoseResponseUncertainty. But, this is not a requirement. It is possible to combine different bins to obtain different uncertainty visualizations. For example, this allows to estimate the total uncertainty of the dose-response curve. For this, the uncertainties of the individual parameters of the K_tau density are estimated as in Example: Individual uncertainty:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"epitope_bins = collect(1:length(adaptive_result.grid))\nprintln(epitope_bins) # hide","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"adaptive_options = AdaptiveOptions(objective = :log_posterior, \n\t\tprior_generator = scaled_log_volume_prior(500),\n\t\toffset = adaptive_result.optimizer[end]\n\t\t)\n\neu = EpitopeUncertainty(data,adaptive_result.grid, epitope_bins, \n\t\tlevels = [1e-10,1e-5,0.1,0.25,0.5,0.75,0.9,1], \n\t\toptions = adaptive_options\n\t\t)\n","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"eu = deserialize(\"examples/uncertainty_total/eu.jld\") # hide","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"Then, the DoseResponseUncertainty is constructed but with the global bin from Example: Global uncertainty:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"dr_bins = [collect(1:length(adaptive_result.grid))]\nconcentrations = LogRange(extrema(data.independent)...,100)\ndu = DoseResponseUncertainty(adaptive_result.grid, eu, concentrations, bins = dr_bins)","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"using Measures # hide\n\ndu_plot, eu_plot = uncertainty_plot(eu,du,adaptive_result.grid, eu_arguments = eu_options(8, bins = epitope_bins,  hide_labels = false), du_arguments = du_options(8, hide_labels = false)) # hide\n\ndu_plot = plot(du_plot) # hide\nscatter!(data, color = \"Dark Orange\", label = \"data\") # hide\n\nplot(eu_plot, du_plot, layout = (1,2), size = (800,300), margins = 5mm) # hide","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"info: Interpretation\nFor the uncertainty of the K_tau-density, the interpretation of the uncertainty levels is the same as before in Example: Individual uncertainty and Example: Uncertainty in a single peak. Only a single parameter at a time can be considered while keeping the other parameters fixed to the best fit result.However, the correspondence between the dose-response uncertainty and the density uncertainty is different. An uncertainty level in the dose-response plot now corresponds to any parameter combination in the density plot that is withing the same uncertainty level.","category":"page"},{"location":"QuickStart/#quick_start","page":"Quick start","title":"Quick start","text":"","category":"section"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"The most convenient and recommended way to analyze dose-response data is to use AntibodyMethodsDoseResponseConvenience.jl. This tutorial will not cover all details (e.g. the internal procedure), but will present a short introduction of the basics. To see all details and available options, please have a look at the AnitbodyMethodsDoseResponseConvenience API.","category":"page"},{"location":"QuickStart/#Starting-point","page":"Quick start","title":"Starting point","text":"","category":"section"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"Suppose, a dose-response experiment with 3 replicates was conducted (of course, any number of replicates can be used and will work in the same way), leading to the following dose-response curves:","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"using AntibodyMethodsDoseResponseConvenience, Measures # hide\nresults, data, replicates =  load_results(\"examples/default_concentrations\") # hide\n\nscatter(data.independent, replicates[1].dependent, xaxis = :log, label = \"replicate 1\", legend = :topleft, xlabel = \"concentration\", ylabel = \"response\") # hide\nscatter!(data.independent, replicates[2].dependent, xaxis = :log, label = \"replicate 2\", markershape = :rect) # hide\nscatter!(data.independent, replicates[3].dependent, xaxis = :log, label = \"replicate 3\", markershape = :utriangle) # hide","category":"page"},{"location":"QuickStart/#Loading-Data","page":"Quick start","title":"Loading Data","text":"","category":"section"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"Importing general data into Julia is not the scope of the AntibodyMethods packages. For this, use e.g. DelimitedFiles.jl or CSV.jl in conjunction with DataFrames.jl. Nevertheless, as short introduction, assume that the data is stored in a csv file, where the columns are (concentrations, replicate 1, ..., replicate 3). Using DelimitedFiles.jl the data can be imported as follows:","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"using DelimitedFiles\ncsv_data = readdlm(\"path_to_file\")","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"csv_data = hcat(data.independent, replicates[1].dependent,replicates[2].dependent,replicates[3].dependent) # hide","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"To separate the different columns into independent arrays, which will be needed in the following, use:","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"conc  = csv_data[:,1] # concentrations\nrep_1 = csv_data[:,2] # replicate 1\nrep_2 = csv_data[:,3] # replicate 2\nrep_3 = csv_data[:,4] # replicate 3\nnothing #hide","category":"page"},{"location":"QuickStart/#Defining-a-fitting-condition","page":"Quick start","title":"Defining a fitting condition","text":"","category":"section"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"Before the data can be analyzed (model fitting), it needs to be summarized in a FittingCondition object. A FittingCondition object contains both the data and the fitting instructions, which can be specified with keywords. The (recommended) default analysis can be obtained by only passing the data, and the scale keyword.","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"fitting_condition = FittingCondition(conc, rep_1,rep_2,rep_3, \n\t\t\tscale = 500, \n\t\t\tpath = \"path_to_store_results\"\n\t\t)\nnothing # hide","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"info: The scale keyword\nTo avoid overfitting of sparse, noisy dose-response data, some sort of regularization constraint is necessary. The scale keyword determines the scale of a penalty term to prevent jagged/spiky histograms. Not using the scale keyword results in a weighted least squares objective.","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"warning: Inappropriate scale values\nToo small scale values only lead to an inefficient least squares objective. Too large scale values, however, can prevent the model to replicate the data at all. In cases, where the fitting result does not correspond to the data at all, try significantly smaller scale values.","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"info: The path keyword\nSince curve-fitting can be a time-consuming process, it is recommended to save the results into files. This allows to re-plot the results at a later time, without having to re-run the fitting process. The path keyword defines the directory for the result files. If path=\"\", which is the default option, no files are saved.","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"tip: Different measurement errors\nConstructing a FittingCondition object by passing the different replicate responses will default to the standard deviation of the data points for the measurement error. If only a single response is used, the replicates field will be empty (nothing) and the measurement errors are set to ±1. Different errors can be used by constructing the FittingData object manually:errors = 0.1 .* responses\ndata = FittingData(concentrations,responses, errors)\nfitting_condition = FittingCondition(data, scale = 500, path = \"path_to_store_results\")","category":"page"},{"location":"QuickStart/#Fitting-a-condition","page":"Quick start","title":"Fitting a condition","text":"","category":"section"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"After defining a FittingCondition, the data can be analyzed to obtain the estimated K_tau-density. Since the fitting instructions are already contained in the FittingCondition object, fitting the data is just a simple function call:","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"results = fit_condition(fitting_condition)","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"fit_condition returns an AdaptiveResult object results. If a path is specified in the FittingCondition object, the results and data are also saved into files.","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"To keep the rest of this tutorial identical for both cases, results and data just obtained and results and data loaded from files, we define:","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"data = fitting_condition.data\nreplicates = fitting_condition.replicates","category":"page"},{"location":"QuickStart/#Loading-results","page":"Quick start","title":"Loading results","text":"","category":"section"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"In general, it is not necessary to load the results, as fit_condition returns the results. However, since the fitting process is time-consuming, it is a good idea to save the results into files (see path keyword above). After e.g. a restart of Julia, the results and data can be loaded as follows:","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"results, data, replicates = load_results(\"path_to_stored_results\")","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"This allows to re-plot the results at a later time, without the need to re-run the analysis.","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"warning: Warning\nThe results, data and replicates are saved with Serialization.jl. Loading objects into a new instance of Julia does not re-instantiate referenced functions. In other words, the distribution functions of loaded FittingData objects do not work. Hence, loaded FittingData objects cannot be used for fitting. Instead, one should define new FittingData objects from scratch:new_data = FittingData(data.independent, data.dependent, data.errors, distributions = ....)The default distributions created by the FittingCondition constructor are(y,m,Δy)-> -(y-m)^2/Δy^2","category":"page"},{"location":"QuickStart/#Plotting-the-results","page":"Quick start","title":"Plotting the results","text":"","category":"section"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"To visualize the results, different plotting functions are provided. The most straightforward one is bin_analysis_plot, which returns 2 plots, the dose-response plot and the density plot:","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"using Measures\ndr_plot, density_plot = bin_analysis_plot(results,data,replicates)\nplot(dr_plot, density_plot, layout = (1,2), size = (800,300), margins = 4mm)","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"The Measures package is used here, to define the margins between the individual plots.","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"info: Plot objects\nAntibodyMethodsDoseResponseConvenience.jl uses Plots.jl in the background to generate the plots. All methods and options of Plots.jl are immediately available; it is not necessary to import Plots.jl with using Plots. The returned plots dr_plot and density_plot are full plot objects, that can be saved directly with savefig(dr_plot,\"file_name\"). Plots.jl also allows to re-draw plot objects, allowing to compose images (see Partial plotting and the combination of plots).","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"The second plotting function is peak_analysis_plot, which visualizes the effect of different peaks on the dose-response curve:","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"individual_dr_plot, cumulative_dr_plot, peak_plot = peak_analysis_plot(results, data)\nplot(individual_dr_plot, cumulative_dr_plot, peak_plot, layout = (2,2), size = (800,600))","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"The top-left plot shows the individual dose-response curves of the different peaks (bottom-left plot) as they would appear if only the respective peak was present alone. The cumulative plot (top-right) shows the contribution of each peak to the total dose-response curve.","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"info: Selection of peaks\nWithout additional keywords, the peaks are determined automatically with peak_detection. Peak regions can also be manually selected. E.g. two isolated ranges 10^-710^-5 and 10^-4 10^-3 could be selected using bins = [[1e-7,1e-5],[1e-4,1e-3]].","category":"page"},{"location":"QuickStart/#partial_plotting","page":"Quick start","title":"Partial plotting and the combination of plots","text":"","category":"section"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"Note that the peak analysis plots did not contain the replicates. This is by design, as the different plots can be combined. For this, we create a partial bin_analysis_plot, where only the data points and the replicates are plotted:","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"dr_data_plot, empty_density_plot = bin_analysis_plot(nothing,data, replicates)\nplot(dr_data_plot)","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"Setting any of the arguments to nothing will omit the argument in the plot. E.g. just plotting the resulting curve, without the data can be achieved with bin_analysis_plot(results,nothing,nothing).","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"The cumulative dose-response, i.e. the contribution of the peaks to the total dose-response curve, can now be plotted on top of the data plot dr_data_plot, using the additional keyword cumulative_dr_plot = dr_data_plot. Since the data points are already contained in the dr_data_plot, they should not be plotted again with peak_analysis_plot, hence the argument nothing:","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"individual_dr_plot, cumulative_dr_plot, peak_plot = peak_analysis_plot(results, nothing, cumulative_dr_plot = dr_data_plot)\nplot(cumulative_dr_plot, peak_plot, layout = (1,2), size = (800,300), margins = 4mm)","category":"page"},{"location":"QuickStart/#plotting_options","page":"Quick start","title":"Plotting options","text":"","category":"section"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"The plotting functions bin_analysis_plot, peak_analysis_plot and uncertainty_plot use keyword-generating functions to modify the plotting options. The keyword-generating functions generate the default keyword arguments for the plot, but allow to overwrite the individual keywords. For example the data_options function generates the following keywords:","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"data_options()","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"The individual keywords can by changed when calling the function. Furthermore, it is possible to add new keywords:","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"data_options(label = \"new label text\", markershape = :utriangle)","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"There is no need to save the resulting keyword arguments. The keyword generating function can be called (as keyword argument) in the plotting function:","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"dr_plot, empty_plot = bin_analysis_plot(results,data, replicates,\n\tdata_arguments = data_options(label = \"new label text\", markershape = :utriangle)\n\t)\nplot(dr_plot)","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"info: Why keyword generating functions?\nThe first idea to allow plot modifications involves global keywords, that could then be changed individually. However, different objects of the plots (e.g. the result and the data) have coinciding keywords, e.g. the color. But writing new, unique keywords for all the existing Plots.jl keywords is impossible.Hence tuples of keywords that correspond to the different parts of the plot (e.g. the result, the data and the replicates) are used. This allows to use the same keyword for different parts of the plot. To define the default behavior, a default tuple of keywords could be used. However, then if only one keyword needed to be changed, the user would have to create a new tuple, copying over the unchanged keywords, which is inconvenient. Thus, keyword-(tuple)-generating functions are provided that produce the default keyword tuple but allow to change individual keywords. ","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"Another example of generating functions, are the base-plot functions. In the previous section (Partial plotting and the combination of plots) it was used that bin_analysis_plot, peak_analysis_plot and uncertainty_plot plot on top of preexisting plots. In fact, even when e.g. dr_plot is not explicitly changed, dr_plot = dr_base_plot() is used to create an empty plot (with some options pre-configured). Calling dr_base_plot allows to change those pre-configured options:","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"dr_plot, empty_plot = bin_analysis_plot(results,data, replicates,\n\t\tdr_plot = dr_base_plot(xlabel = \"concentrations\", legend = :none)\n\t\t)\nplot(dr_plot)","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"A complete list of these generating functions and how to use them in the different plotting functions can be found in the AnitbodyMethodsDoseResponseConvenience API.","category":"page"},{"location":"MeasurementData/#Measurement-data","page":"Measurement data","title":"Measurement data","text":"","category":"section"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"To work with measurement data, it needs to be stored in a FittingData object from FittingObjectiveFunctions.jl.","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"using FittingObjectiveFunctions\nfitting_data = FittingData(concentrations, mean_responses, uncertainties)","category":"page"},{"location":"MeasurementData/#Check-data","page":"Measurement data","title":"Check data","text":"","category":"section"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"Good dose-response data must satisfy the following properties:","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"The concentrations and the responses must be positive.\nAll values must be real numbers.\nNo NaN or Inf.","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"These properties can be checked, using dose_response_check:","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"using AntibodyMethodsDoseResponseConvenience #hide\nnothing #hide","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"dose_response_check(FittingData([1,2],[-1,2]))","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"If dose_response_check does not throw an error, the FittingData object contains proper dose-response data.","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"info: Info\ndose_response_check is used internally by some functions to ensure proper data transformation. E.g. data normalization or depletion corrections require proper dose-response data.","category":"page"},{"location":"MeasurementData/#Normalize-data","page":"Measurement data","title":"Normalize data","text":"","category":"section"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"Dose-response curves from different sources may require normalization. For example, replicates from different experiments could have used different exposure times. There are two methods to normalize the data. The first method requires a reference signal (scanned during the experiments) to which the other responses can be normalized. The second method normalizes the dose-response curve s.t. the strongest response is 1.","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"To normalize the data to 1 use the normalize_data function without additional keywords.","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"data = FittingData([1,2,3],[1,2,3])\nnormalize_data(data)","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"To normalize the data to a reference signal, i.e. 2, the reference keyword can be used:","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"normalize_data(data, reference = 2)","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"Another common normalization step is the removal of a constant offset, e.g. caused by autofluorescence. Since both offset removal and reference scaling are applied, it is important to understand the order of the corrections:","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"The offset is subtracted from all response values\nIf the reference keyword is used, the offset is also subtracted from the reference value. This is, because reference measurements often suffer from the same offset.\nThe responses are rescaled\t\nIf the reference keyword was used, all responses are divided by the modified reference value.\nOtherwise, the responses are rescaled, s.t. the largest response is 1.","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"In the following example, 0.5 is subtracted from the response values [1,2,3]->[0.5,1.5,2.5]. Then the responses are divided by the largest response 2.5 to rescale the responses:","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"normalize_data(data, offset = 0.5)","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"info: Measurement errors\nThe measurement errors are also normalized, following standard Gaussian error propagation (reference and offset are without errors). Thus, the measurement errors are just rescaled.","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"Without the reference keyword, it is possible to have the offset value be determined automatically, i.e. the dose-response curve is shifted s.t. the smallest response is zero:","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"normalize_data(data, offset = Inf)","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"Internally, any offset that is too large is replaced by the smallest response value. When the reference keyword is used, it is not recommended to use arbitrary offsets, as they are subtracted from the reference value, too. Furthermore, offset values that are larger than the reference value (after being replaced by the smallest response) throw an error:","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"normalize_data(data, offset = 2, reference = 0.1)","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"println(\"ERROR: DomainError with 1:\") #hide\nprintln(\"The offset value must be smaller than the reference value.\") #hide","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"tip: Mutation of data\nnormalize_data does not mutate the original FittingData object, but returns a normalized copy. To mutate the original object, use normalize_data!.","category":"page"},{"location":"MeasurementData/#Simple-depletion-correction","page":"Measurement data","title":"Simple depletion correction","text":"","category":"section"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"To keep the models computationally simple, e.g. by using analytical solutions, antibody depletion is not accounted for. Yet, depending on the experimental protocol, depletion can be unavoidable. Fortunately, there is simple approximation to obtain new concentrations that define lower bounds for the real binding process that is subject to depletion:","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"Let (a_ir_i) be data points where, a_i denotes the initial antibody concentrations and r_i denotes the corresponding responses. Then lower-bound concentrations are ","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"b_i = a_i - widehatbeta r_i qquad textwhere qquad widehatbeta = max beta in mathbbR_0 mid a_i -beta r_i geq 0  forall i","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"This approximation holds true both for the accumulation model as well as the Langmuir isotherm model, albeit for different reasons (cf Edwards et al and https://arxiv.org/abs/2407.06052). The maximization of the parameter widehatbeta is necessary to obtain a worst-case scenario if the actual proportionality factor between the response signal and the actual number of bound complexes is unknown.","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"To obtain this \"scale bound\" widehatbeta the scale_bound function can be used:","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"β = scale_bound(FittingData([1,2,3],[1,1.5,1.9]))","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"To obtain the lower-bound concentrations b_i, the simple_depletion_correction function can be used:","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"simple_depletion_correction(FittingData([1,2,3],[1,1.5,1.9]), β)","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"Note that a new FittingData object is returned, containing the lower-bound concentrations b_i instead of the initial concentrations a_i. It is possible to use different scales for simple_depletion_correction. But for the scale_bound there is a shortcut (which internally calls scale_bound):","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"simple_depletion_correction(FittingData([1,2,3],[1,1.5,1.9]))","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"tip: Mutation of data\nAgain, simple_depletion_correction does not mutate the original FittingData object, but returns a corrected copy. To mutate the original object, use simple_depletion_correction!.","category":"page"},{"location":"MeasurementData/#measurement_data_plotting","page":"Measurement data","title":"Plotting","text":"","category":"section"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"Of course, FittingData objects can be plotted with any plotting library by calling the fields:","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"using Plots\ndata = FittingData([0,1,2,3,4],[0,1,1.5,1.9,2.1])\nplot(data.independent, data.dependent, yerrors = data.errors)","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"For convenience, AntibodyMethodsDoseResponseRecipes.jl contains plotting recipes for FittingData objects:","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"using Plots, AntibodyMethodsDoseResponseRecipes\ndata = FittingData([0,1,2,3,4],[0,1,1.5,1.9,2.1])\nplot(data)","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"Observe that the data point with concentration = 0 is missing. Since dose-response curves are commonly plotted in a logarithmic scale and since Plots.jl does not automatically remove zero values from logarithmic plots (which become -infty), the plotting recipe introduces the keyword filter_zeros = [true,false]. The filter_zeros keyword expects two Bool values. If the first value is true, all data points with concentration = 0 are removed from the plot. Accordingly, if the second value is true, all data points with response = 0 are removed from the plot.","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"The plotting recipe defines how Plots.jl handles the data inside a FittingData object. Thus, the usual keywords remain usable and can be combined with the filter_zeros keyword:","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"plot(data, color = :red, filter_zeros = [false,false])","category":"page"},{"location":"MeasurementData/#[FittingData](https://translational-pain-research.github.io/FittingObjectiveFunctions-documentation/API/#FittingObjectiveFunctions.FittingData)-and-[FittingCondition](@ref)","page":"Measurement data","title":"FittingData and FittingCondition","text":"","category":"section"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"Internally FittingCondition objects expect measurement data to be stored in FittingData objects. Yet, the quick start guide mentions FittingData objects only as optional method to implement specific measurement errors. This is, because FittingCondition offers constructors that automatically create the FittingData objects.","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"The default constructor uses FittingData objects:","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"data = FittingData([1,2,3],[1,1.5,1.9], [0.4,0.4,0.4], distributions = (y,m,Δy)-> -abs(y-m))\ncondition = FittingCondition(data)\ncondition.data ","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"Using the FittingData constructor allows to specify different measurement errors, as mentioned in the tip, but also different uncertainty distributions for posterior based objectives.","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"The convenience constructor bypasses the need to construct the FittingData explicitly, expecting only the concentrations and the responses:","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"condition = FittingCondition([1,2,3],[1,1.5,1.9])\ncondition.data ","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"Note that the measurement errors are set to 1.","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"Finally, the convenience constructor allows to pass multiple response arrays:","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"condition = FittingCondition([1,2,3],[1,1.5,1.9],[0.8,1.7,2.8])\ncondition.data ","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"If multiple response arrays are provided to the constructor, it calculates the mean values for the responses and uses the standard deviation for the measurement errors. In addition, it adds the individual responses as replicates:","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"condition.replicates ","category":"page"},{"location":"#AntibodyMethodsDoseResponse","page":"Introduction","title":"AntibodyMethodsDoseResponse","text":"","category":"section"},{"location":"#About","page":"Introduction","title":"About","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"AntibodyMethodsDoseResponse.jl, AntibodyMethodsDoseResponseConvenience.jl and AntibodyMethodsDoseResponseRecipes.jl are Julia packages for the analysis of (antibody-binding) dose-response curves.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In essence, the dose-response data is modelled by the following accumulation model (see https://arxiv.org/abs/2407.06052 for further details and applications):","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"r(a) = int_0^infty g(K_tau) left(1- e^-fracaK_tau right)  dK_tau","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"where K_tau sim frac1k_texton is proportionally inverse to the binding rate k_texton and g(K_tau) is the K_tau-density of epitopes. The packages also implement the Langmuir isotherm (equilibrium model). In either case, the analysis consists of a model fit, estimating the density g(K_tau) from measurement data.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using AntibodyMethodsDoseResponseConvenience, Measures # hide\nresults, data, replicates =  load_results(\"examples/default_concentrations\") # hide\ndr_plot, density_plot = bin_analysis_plot(results,data,replicates) # hide\nplot(dr_plot, density_plot, layout = (1,2), size = (800,300), margins = 4mm) # hide","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In this documentation, both the terms density plot and histogram will be used interchangeably to refer to the plot of the estimated density g(K_tau).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"info: The different packages\nPackage Short Description\nAntibodyMethodsDoseResponseConvenience.jl Convenience package for the analysis of dose-response curves. Contains predefined analysis and plotting methods. Recommended for the analysis of dose-response data.\nAntibodyMethodsDoseResponse.jl Minimal package defining the underlying models and methods for the analysis of dose-response curves. Intended for the development of analysis methods from scratch. Requires fewer dependencies.\nAntibodyMethodsDoseResponseRecipes.jl Plots.jl recipes for AntibodyMethodsDoseResponse objects.","category":"page"},{"location":"#About-the-tutorials","page":"Introduction","title":"About the tutorials","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The quick start guide \nA minimal tutorial, covering only the necessary steps to analyze dose-response data without any in-depth explanations. \nFrom here, the AnitbodyMethodsDoseResponseConvenience API is highly recommended to explore the additional options of the convenience functions that are not covered in the minimal tutorial.\nThe recommendation for most users.\nThe Detailed explanations\nCovers the background and the internals of the packages.\nAssumes (at some points) to be read in order from top to bottom.\nThe convenience functions (from the quick start guide) use the same data types and methods internally.\nIntended for developers that need access to the internal methods and that want to take full control over the analysis.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"First, add the registry Translational-Pain-ResearchRegistry:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.Registry.add()\nPkg.Registry.add(RegistrySpec(url = \"https://github.com/Translational-Pain-Research/Translational-Pain-ResearchRegistry\"))","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Then, the packages can be installed as usual. E.g. AntibodyMethodsDoseResponseConvenience.jl, which installs all necessary dependencies for the analysis of dose-response curves:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(\"AntibodyMethodsDoseResponseConvenience\")","category":"page"},{"location":"#How-to-cite-the-package","page":"Introduction","title":"How to cite the package","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If you would like to cite this package for scientific purposes, you might also want to cite the corresponding paper https://arxiv.org/abs/2407.06052.","category":"page"},{"location":"API/#API","page":"AntibodyMethodsDoseResponse","title":"API","text":"","category":"section"},{"location":"API/#Measurement-data-processing","page":"AntibodyMethodsDoseResponse","title":"Measurement data processing","text":"","category":"section"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"dose_response_check","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.dose_response_check","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.dose_response_check","text":"dose_response_check(fitting_data::FittingData)\n\nTest if the FittingData object fitting_data satisfies properties for dose-response data:\n\nonly real numbers\nnumbers must be positive\nno NaN or Inf in the data set\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"normalize_data","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.normalize_data","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.normalize_data","text":"normalize_data!(fitting_data::FittingData; offset::Real = 0, reference::Union{Nothing,Real} = nothing)\n\nReturn the FittingData object fitting_data with normalized response data and errors.\n\nreference = nothing: The reference signal to normalize the responses to. If reference = nothing, the maximal response is used a reference point.\noffset = 0: Signal offset to be subtracted (applies to both the responses and the reference point).\n\nThe normalization of the responses and errors are:\n\nnew_responses = (responses - offset) / (reference - offset)\nerrors =  errors / (reference - offset)\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"normalize_data!","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.normalize_data!","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.normalize_data!","text":"normalize_data!(fitting_data::FittingData; offset::Real = 0, reference::Union{Nothing,Real} = nothing)\n\nNormalize the FittingData object fitting_data by mutation.\n\nreference = nothing: The reference signal to normalize the responses to. If reference = nothing, the maximal response is used a reference point.\noffset = 0: Signal offset to be subtracted (applies to both the responses and the reference point).\n\nThe normalization of the responses and errors are:\n\nnew_responses = (responses - offset) / (reference - offset)\nerrors =  errors / (reference - offset)\n\n\n\n\n\n","category":"function"},{"location":"API/#Depletion-correction-of-measurement-data","page":"AntibodyMethodsDoseResponse","title":"Depletion correction of measurement data","text":"","category":"section"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"scale_bound","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.scale_bound","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.scale_bound","text":"scale_bound(fitting_data::FittingData)\n\nGet the upper bound for the scale factor β s.t.  a_i - β*r_i ≥ 0, where r_i are the responses and a_i are the (initial) antibody concentrations.\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"simple_depletion_correction","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.simple_depletion_correction","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.simple_depletion_correction","text":"simple_depletion_correction(fitting_data::FittingData,scale::Real)\n\nReturn the depletion-corrected FittingData object.\n\nThe concentrations are corrected to concentration - scale * response.\n\n\n\n\n\nsimple_depletion_correction(fitting_data::FittingData)\n\nReturn depletion-corrected FittingData object using the largest possible scale factor.\n\nThe concentrations are corrected to concentration - scale * response.\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"simple_depletion_correction!","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.simple_depletion_correction!","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.simple_depletion_correction!","text":"simple_depletion_correction!(fitting_data::FittingData,scale::Real)\n\nDepletion-correct the FittingData object fitting_data by mutation.\n\nThe concentrations are corrected to concentration - scale * response.\n\n\n\n\n\nsimple_depletion_correction!(fitting_data::FittingData)\n\nDepletion-correct the FittingData object fitting_data by mutation, using the largest possible scale factor.\n\nThe concentrations are corrected to concentration - scale * response.\n\n\n\n\n\n","category":"function"},{"location":"API/#Models","page":"AntibodyMethodsDoseResponse","title":"Models","text":"","category":"section"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"accumulation_model","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.accumulation_model","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.accumulation_model","text":"accumulation_model(grid::OneDimGrid; offset = nothing)\n\nCreate a multi-epitope accumulation model. Returns (model,λ,centers,volumes) where \n\nmodel is a ModelFunctions object.\nλ is an initial parameter array (the weights of the grid and the offset if offset != nothing). If offset != nothing, the last element is the offset parameter λ[end] = offset.\ncenters and volumes are the remaining properties of the grid, see export_all\n\nModel function\n\nThe following model function and partial derivatives are used:\n\ntextmodel(alambda) = lambda_e + sum_i lambda_i left(1-e^-fracac_iright)  approx  lambda_e + sum_i int_l_i^u_i fraclambda_iu_i-l_ileft(1-e^-fracakright)  dk \n\npartial_lambda_j textmodel(alambda) = 1-e^-fracac_i quad qquad partial_lambda_e textmodel(alambda) = 1\n\nwhere a is the antibody concentration, c_i are the centers of the grid intervals u_il_i and lambda_e is the offset (if offset != nothing).\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"langmuir_model","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.langmuir_model","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.langmuir_model","text":"langmuir_model(grid::OneDimGrid; offset = nothing)\n\nCreate a multi-epitope Langmuir model. Returns (model,λ,centers,volumes) where \n\nmodel is a ModelFunctions object.\nλ is an initial parameter array (the weights of the grid and the offset if offset != nothing). If offset != nothing, the last element is the offset parameter λ[end] = offset.\ncenters and volumes are the remaining properties of the grid, see export_all.\n\nModel function\n\nThe following model function and partial derivatives are used:\n\ntextmodel(alambda) = lambda_e + sum_i fraclambda_icdot a (u_i - l_i) lnleft(fraca+u_ia+l_iright)  =  lambda_e + sum_i int_l_i^u_i fracfraclambda_iu_i - l_i1+fracka  dk \n\npartial_lambda_j textmodel(alambda) = fracau_j-l_j lnleft(fraca+u_ja+l_jright)quad qquad partial_lambda_e textmodel(alambda) = 1\n\nwhere a is the antibody concentration, l_iu_i are the intervals of the grid and lambda_e is the offset (if offset != nothing).\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"accumulation_inv_const_model ","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.accumulation_inv_const_model","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.accumulation_inv_const_model","text":"accumulation_inv_const_model(grid::OneDimGrid; offset = nothing)\n\nCreate a multi-epitope accumulation model with 1/K_τ = k_a * τ as constant domain. Returns (model,λ,centers,volumes) where \n\nmodel is a ModelFunctions object.\nλ is an initial parameter array (the weights of the grid and the offset if offset != nothing). If offset != nothing, the last element is the offset parameter λ[end] = offset.\ncenters and volumes are the remaining properties of the grid, see export_all\n\nModel function\n\nThe following model function and partial derivatives are used:\n\ntextmodel(alambda) = lambda_e + sum_i lambda_i left(1+frac1acdot(u_i-l_i)left(e^-a u_i-e^-a l_i right) right) =   lambda_e + sum_i int_l_i^u_i fraclambda_iu_i-l_ileft(1-e^-a kright)  dk \n\npartial_lambda_j textmodel(alambda) = 1+frac1acdot(u_i-l_i)left(e^-a u_i-e^-a l_i right) quad qquad partial_lambda_e textmodel(alambda) = 1\n\nwhere a is the antibody concentration, c_i are the centers of the grid intervals u_il_i and lambda_e is the offset (if offset != nothing).\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"langmuir_inv_const_model","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.langmuir_inv_const_model","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.langmuir_inv_const_model","text":"langmuir_inv_const_model(grid::OneDimGrid; offset = nothing)\n\nCreate a multi-epitope Langmuir model with 1/K_d = k_a / k_d as constant domain. Returns (model,λ,centers,volumes) where \n\nmodel is a ModelFunctions object.\nλ is an initial parameter array (the weights of the grid and the offset if offset != nothing). If offset != nothing, the last element is the offset parameter λ[end] = offset.\ncenters and volumes are the remaining properties of the grid, see export_all\n\nModel function\n\nThe following model function and partial derivatives are used:\n\ntextmodel(alambda) = lambda_e + sum_i lambda_i left(1+ frac1acdot (u_i-l_i) lnleft(fraca l_i +1a u_i +1right)right)  = lambda_e + sum_i int_l_i^u_i fracfraclambda_iu_i - l_i1+frac1acdot k  dk  \n\npartial_lambda_j textmodel(alambda) = 1+ frac1acdot (u_i-l_i) lnleft(fraca l_i +1a u_i +1right)quad qquad partial_lambda_e textmodel(alambda) = 1\n\nwhere a is the antibody concentration, l_iu_i are the intervals in the grid and lambda_e is the offset (if offset != nothing).\n\n\n\n\n\n","category":"function"},{"location":"API/#Result-type","page":"AntibodyMethodsDoseResponse","title":"Result type","text":"","category":"section"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"DoseResponseResult","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.DoseResponseResult","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.DoseResponseResult","text":"struct DoseResponseResult\n\nData type to store dose-response result data (e.g. from a dose-response-curve fitting or a simulation).\t\n\nFields\n\nconcentrations: Antibody concentrations.\nresponses: Response values.\n\nDefault constructor\n\nDoseResponseResult(concentrations,responses)\n\nModel constructor\n\nDoseResponseResult(grid::OneDimGrid,concentrations; \n\toffset::Real = 0,\n\tmodel::Function = accumulation_model\n)\n\nCalculate a dose-response curve from a K_τ grid and a model for given concentrations. The offset value is a global additive shift for all response values.\n\nThe available model functions are accumulation_model, accumulation_inv_const_model, langmuir_model and langmuir_inv_const_model.\n\n\n\n\n\n","category":"type"},{"location":"API/#Adaptive-fitting","page":"AntibodyMethodsDoseResponse","title":"Adaptive fitting","text":"","category":"section"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"AdaptiveOptions","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.AdaptiveOptions","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.AdaptiveOptions","text":"mutable struct AdaptiveOptions\n\nData type to define adaptive_dose_response_fit options.\n\nConstructor\n\nAdaptiveOptions(keywords...)\n\nThe following keywords (with default values) are available:\n\nname::AbstractString = \"Adaptive optimization\": The name that is used when show_progress==true.\nshow_progress::Bool = true: Show progress in standard output.\niterations::Integer = 1: Number of refinement iterations.\nmodel::Function = accumulation_model: The model-function that is used for the data-fit. The available model functions are accumulation_model, accumulation_inv_const_model, langmuir_model and langmuir_inv_const_model.\noffset = nothing: Offset parameter for the model function. If nothing, no offset is used.\nobjective::Symbol = :lsq. The objective function for the data-fit. Available are :lsq, :posterior and :log_posterior.\nprior_generator::Function = default_prior_generator: The function that generates the prior. The function must have the signature (grid_centers,grid_volumes,offset) and must return a function λ-> prior(λ) or λ-> log_prior(λ) in case of a :log_posterior objective. The default_prior_generator generates a uniform prior λ-> 0 for the log-posterior objective.\ndistribution_derivatives = nothing: Array of partial derivatives of the logarithmic distributions for the log-posterior objective. See log_posterior_gradient.\nprior_gradient_generator = default_prior_gradient_generator: The function that generates the log-prior gradient (see  log_posterior_gradient). The function must have the signature (grid_centers,grid_volumes,offset) and must return a function λ-> ∇log_prior(λ). The default_prior_gradient_generator returns nothing which internally corresponds to the uniform prior for the log-posterior objective.\nblock_variation::Function = log_area_scaled_variation and selection::Function = maximum are the refinement options of refine!.\n\n\n\n\n\n","category":"type"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"area_scaled_variation","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.area_scaled_variation","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.area_scaled_variation","text":"area_scaled_variation(center, volume, weight, \n\tneighbor_centers, neighbor_volumes, neighbor_weights)\n\nBlock variation function for refine!. Variation value based on the difference of the weights, scaled with the area (volume) of the corresponding block.\n\nmean(@. abs(weight * volume - neighbor_weights * neighbor_volumes))\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"log_area_scaled_variation","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.log_area_scaled_variation","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.log_area_scaled_variation","text":"log_area_scaled_variation(center, volume, weight, \n\tneighbor_centers, neighbor_volumes, neighbor_weights)\n\nBlock variation function for refine!. Variation value based on the difference of the weight, scaled with the visible area (in a logarithmic plot) of the corresponding block.\n\nlog_volume = (log10(center + volume / 2) - log10(center - volume / 2))\nneighbor_log_volumes = @. (log10(neighbor_centers + neighbor_volumes / 2) - log10(neighbor_centers - neighbor_log_volumes / 2))\nmean(@. abs(weight * log_volume  - neighbor_weights * neighbor_log_volumes))\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"adaptive_dose_response_fit","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.adaptive_dose_response_fit","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.adaptive_dose_response_fit","text":"adaptive_dose_response_fit(initial_grid::OneDimGrid, \n\tdata::FittingData, \n\tminimizer::Function; \n\toptions::AdaptiveOptions=AdaptiveOptions()\n)\n\nFit dose-response data (with adaptive grid refinements depending on the options) and return an AdaptiveResult object. The initial gird is not mutated. For the AdaptiveResult object a copy of the gird is created.\n\nMinimizer function\n\nThe sign of posterior and log-posterior objectives is flipped for consistency reasons. A minimizer needs to be used for all objectives (:lsq, :posterior, :log_posterior).\nminimizer: The function that minimizes the objective function. It needs to be specified by the user and must have the signature (objective_function, objective_gradient!,parameters).\nThe objective_function always has the signature (parameters).\nThe objective_gradient! can be nothing. Otherwise it must have the signature (gradient_vector, parameter). It must mutate the gradient_vector and return the mutated gradient_vector.\nparameters is the initial parameter array to start minimization from.\n\nGradients for minimization\n\nWhether objective_gradient! is nothing or a proper function depends on the specified options (see AdaptiveOptions).\n\nThe :lsq objective always provides analytical gradients.\nThe :posterior objective never provides analytical gradients. \nThe:log_posterior objective only provides analytical gradients if distribution_derivatives != nothing.\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"AdaptiveResult","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.AdaptiveResult","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.AdaptiveResult","text":"mutable struct AdaptiveResult\n\nData type used by adaptive_dose_response_fit to summarize the results.\n\nThe struct has the following fields:\n\nresult: The DoseResponseResult object corresponding to the fit result.\ngrid: The grid (with imported weights) corresponding to the fit result.\noptimizer: The raw result parameter.\nobjective_value: The objective-function value of optimizer.\ntime: The elapsed time for the model fit (in seconds).\n\n\n\n\n\n","category":"type"},{"location":"API/#Convenience-methods","page":"AntibodyMethodsDoseResponse","title":"Convenience methods","text":"","category":"section"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"LogRange","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.LogRange","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.LogRange","text":"LogRange(start::Real,stop::Real,n::Integer, base::Real = 10.0)\n\nReturn a vector with n values logarithmically distributed between start and stop. The logarithm base can be changed with the last, optional argument.\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"peak_detection","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.peak_detection","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.peak_detection","text":"peak_detection(grid::OneDimGrid, relative_threshold::Real = 0.1; \n\tvolume_normalization::Symbol = :log, \n\tfill::Bool = true\n)\n\nReturn (peak_group_indices,peak_group_domains) w.r.t. the relativ_ threshold.\n\npeak_group_indices contains the index-vectors of the peaks. The index order is the order of export_weights and export_all.\npeak_group_domains contains the intervals covered by the respective peaks.\nThe cutoff threshold is determined by relative_threshold * largest_weight.\nIf fill == true, the gaps between the peaks are added to peak_group_indices and peak_group_domains.\nvolume_normalization normalizes the weights of the grid (without mutation) before the peaks are determined. :none uses the raw weights. :linear divides the weights by the block volume and :log divides the weight by the block volume in a logarithmic scale.\n\n\n\n\n\n","category":"function"},{"location":"API/#Uncertainty-estimation","page":"AntibodyMethodsDoseResponse","title":"Uncertainty estimation","text":"","category":"section"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"EpitopeUncertainty","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.EpitopeUncertainty","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.EpitopeUncertainty","text":"struct EpitopeUncertainty\n\nData type to store uncertainty estimates for the weights of a K_τ grid.\n\nFields\n\nlevels: List of uncertainty levels. They can be sample quantiles or fractions of the best objective value, depending on the constructor.\nlower: Matrix of estimated lower bounds for the weights at the corresponding uncertainty levels (dimension order : [level, grid parameter index]).\nupper: Matrix of estimated upper bounds for the wights at the corresponding uncertainty levels (dimension order : [level, gird parameter index]).\nlower_offset: Vector of lower bounds for the offset parameter corresponding to the uncertainty levels.\nupper_offset: Vector of upper bounds for the offset parameter corresponding to the uncertainty levels.\n\n\n\n\n\nDefault constructor\n\nEpitopeUncertainty(levels, lower, upper, lower_offset= nothing, upper_offset = nothing)\n\n\n\n\n\nConstruction from bin-wise shifting\n\nEpitopeUncertainty(data::FittingData,grid::OneDimGrid, bins = collect(1:length(grid)); \n\tkeywords...)\n\nEstimate uncertainty by shifting all grid weights uniformly, one bin at a time, while keeping the other bins fixed. Admissible weights (for a given level) are determined by calculating the objective-function value (objective function automatically generated) for the shifted weights.\n\nThe bins can be defined as vector of indices, e.g. [[1,2,3],[4,5,6]] or [1,3,5] which is converted to [[1],[3],[5]]. To obtain bin indices from the grid-domain, use select_indices.\n\nThe following keywords are available:\n\nlevels = collect(0.1:0.1:1): The uncertainty levels as fractions of the best objective value.\nsteps::Integer = 10^4: Number of intermediate shifts to be tested. The maximal shift range is determined automatically.\nbisections::Integer = 10^2: Number of interval-bisection steps to determine the maximal shift range.\nvolume_normalization = :none: Changes the scaling of the weight shifts for each individual weight in a bin. Use :none to apply the same shift for each weight. Use :linear to scale the shifts with the interval volumes corresponding to the weights.  And use :log to scale the sifts with the visual interval volumes (as they appear in a logarithmic plot) corresponding to the weights.\noptions::AdaptiveOptions = AdaptiveOptions(): The objective function is automatically generated, using the same construction as adaptive_dose_response_fit. See AdaptiveOptions and adaptive_dose_response_fit for the details. To use the offset estimation from a fit result, add the estimated value to the AdaptiveOptions with the offset keyword: options = AdaptiveOptions(other_options..., offset = estimated_offset).\n\n\n\n\n\nConstruction from samples\n\nEpitopeUncertainty(samples; keywords... )\n\nEstimate the uncertainty as credibility intervals (symmetric interval around the median) from samples (drawn from a posterior distribution). The samples can either be passed as array of samples (parameters) or as matrix (order: [parameter index, sample index]).\n\nThe following keywords are available:\n\nlevels = collect(0.1:0.1:1): The uncertainty levels as quantiles.\noffset::Bool = false: If true the last parameter element is treated as offset parameter, otherwise, all parameters are treated as grid weights.\n\n\n\n\n\n","category":"type"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"DoseResponseUncertainty","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.DoseResponseUncertainty","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.DoseResponseUncertainty","text":"struct DoseResponseUncertainty\n\nData type to store uncertainty estimates for the response values of a DoseResponseResult object.\n\nFields\n\nlevels: List of uncertainty levels, corresponding to the uncertainty levels of a EpitopeUncertainty object (if constructed from an EpitopeUncertainty object).\nconcentration: Vector of concentrations (no uncertainty).\nlower: Matrix of estimated lower bounds for the responses at the corresponding uncertainty level (dimension order : [level, concentration/response index]).\nupper: Matrix of estimated upper bounds for the responses at the corresponding uncertainty level (dimension order : [level, concentration/response index]).\n\n\n\n\n\nDefault constructor\n\nDoseResponseUncertainty(levels,concentrations,lower,upper)\n\n\n\n\n\nConstruction from an EpitopeUncertainty object\n\nDoseResponseUncertainty(grid::OneDimGrid,\n\teu::EpitopeUncertainty,\n\tconcentrations::AbstractVector; \n\tkeywords...\n)\n\nEstimate the dose-response uncertainty from an EpitopeUncertainty object eu for the provided concentrations. The grid should be the grid that was used to create the EpitopeUncertainty object eu.\n\nThe following keywords are available:\n\nbins = [collect(1:length(grid))]: The response bounds are calculated as point-wise minima/maxima of responses created from the grid weights, where one bin at a time is replaced with the EpitopeUncertainty lower and upper bound, while keeping the other weights fixed. For the minima/maxima all response values, iterating over all bins, are considered. Ideally, the bins should correspond to the bins that were used to construct the EpitopeUncertainty object eu.\nmodel::Function = accumulation_model: The model that is used to calculate the response values. The available model functions are accumulation_model, accumulation_inv_const_model, langmuir_model and langmuir_inv_const_model.\n\nThere is no offset keyword, as the offsets are determined by the EpitopeUncertainty object.\n\n\n\n\n\n","category":"type"}]
}
